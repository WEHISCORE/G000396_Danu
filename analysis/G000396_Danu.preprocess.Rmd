---
title: "Preprocessing the G000396 mini-bulk data set"
description: |
author:
  - name: Peter Hickey
    url: https://peterhickey.org
    affiliation: Cellular Genomics Projects Team (formerly SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/rory-bowden/4536/wehi-advanced-genomics-facility
  - name: Millie Dunstone
    affiliation: Research Assistant, WEHI
date: "`r Sys.Date()`"
editor_options:
  chunk_output_type: console
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(scales)
library(ggplot2)
library(cowplot)
library(patchwork)
library(ggrepel)
library(gt)
library(scater)
library(limma)

knitr::opts_chunk$set(fig.path = "G000396_Danu.preprocess_files/")

# NOTE: The following is a workaround to the lack of support for tabsets in 
#       distill (see https://github.com/rstudio/distill/issues/11 and 
#       https://github.com/rstudio/distill/issues/11#issuecomment-692142414 in 
#       particular).
xaringanExtra::use_panelset()
```

# Setting up the data

We start from the count matrices created in [`code/scPipe.R`](../code/scPipe.R`), specifically the [UMI counts (a.k.a. UMI-deduplicated) data](../data/SCEs/G000396_Danu.UMI_deduped.scPipe.SCE.rds) and [read counts (a.k.a. not UMI-deduplicated) data](../data/SCEs/G000396_Danu.not_UMI_deduped.scPipe.SCE.rds).

<aside>
UMI stands for unique molecular identifier.
</aside>

```{r}
sce_deduped <- readRDS(
  here("data", "SCEs", "G000396_Danu.UMI_deduped.scPipe.SCE.rds"))
sce_not_deduped <- readRDS(
  here("data", "SCEs", "G000396_Danu.not_UMI_deduped.scPipe.SCE.rds"))

colnames(sce_not_deduped) <- sub(
  "\\.not_UMI_deduped",
  "",
  colnames(sce_not_deduped))
stopifnot(
  identical(rownames(sce_deduped), rownames(sce_not_deduped)),
  identical(colnames(sce_deduped), colnames(sce_not_deduped))) 

# Combine UMI and read counts a single SCE.
sce <- sce_deduped
assay(sce, "UMI_counts") <- assay(sce_deduped, "counts")
assay(sce, "read_counts") <- assay(sce_not_deduped, "counts")
# NOTE: Nullify some now-unrequired data.
assay(sce, "counts") <- NULL
sce$UMI_deduped <- NULL
```

We combine these into a single object^[In the terminology of Bioconductor this is called a *SingleCellExperiment* object.] containing both the UMI counts and the read counts for `r number(nrow(sce), big.mark = ",")` genes and `r number(ncol(sce), big.mark = ",")` samples.

## Experimental design

```{r}
# Initial tidying of sample metadata
sce$plate_number <- factor(sce$plate_number)
sce$well_position <- factor(
  sce$well_position,
  unlist(lapply(LETTERS[1:16], function(x) paste0(x, 1:24))))
sce$sample_type <- factor(sce$sample_type)
sce$original_plate <- factor(sce$original_plate)
sce$cell_line <- factor(
  sce$cell_line,
  levels = c("GID1KO", "GID2KO", "GID7KO", "GID8KO", "GID9KO", "WT", "N/A"))
sce$timepoint <- factor(
  sce$timepoint,
  levels = c(paste0("Day_", c(3, 6, 9, 12)), "N/A"))
sce$biological_replicate <- factor(
  sce$biological_replicate,
  levels = c(1:5, "N/A"))
sce$technical_replicate <- factor(
  sce$technical_replicate, 
  levels = c(1:2, "N/A"))
sce$sequencing_run <- factor(sce$sequencing_run)
sce$sample <- interaction(
  sce$cell_line, 
  sce$timepoint, 
  sce$biological_replicate, 
  drop = TRUE, 
  lex.order = TRUE)
```

### Introduction

This is a large and somewhat complex experiment.
There are `r number(sum(sce$sample_type != "empty"), big.mark = ",")` mini-bulk libraries and `r number(sum(sce$sample_type == "empty"), big.mark = ",")` negative control 'empty' libraries^[The negative control samples have `N/A` recorded for the various sample metadata.].
The tables below summarise the samples in this experiment.

::::: {.panelset}

::: {.panel}

#### Technical replicates

```{r}
tech_reps_tbl <- as.data.frame(colData(sce)) |>
  dplyr::group_by(cell_line, timepoint, biological_replicate) |>
  dplyr::count() |> 
  dplyr::group_by(cell_line, timepoint)

gt(
  tech_reps_tbl,
  caption = md(
    "Number of technical replicates per `cell_line`-`timepoint`-`biological_replicate` combination.")) |>
  fmt_number(columns = n, decimals = 0) |>
  summary_rows(
    columns = n, 
    fns = list(subtotal ~ sum(.)), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  grand_summary_rows(
    columns = n, 
    fns = total ~ sum(.), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  tab_options(
    summary_row.background.color = "lightgrey",
    grand_summary_row.background.color = "darkgrey")
```

:::

::: {.panel}

#### Biological replicates (per cell line)

```{r}
bio_reps_tbl <- as.data.frame(colData(sce)) |>
  dplyr::select(cell_line, timepoint, biological_replicate) |>
  dplyr::group_by(cell_line, timepoint) |>
  dplyr::distinct() |>
  dplyr::count() |>
  dplyr::group_by(cell_line)

gt(
  bio_reps_tbl,
  caption = md(
    "Number of biological replicates per `cell_line`-`timepoint` combination.")) |>
  fmt_number(columns = n, decimals = 0) |>
  summary_rows(
    columns = n, 
    fns = list(subtotal ~ sum(.)), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  grand_summary_rows(
    columns = n, 
    fns = total ~ sum(.), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  tab_options(
    summary_row.background.color = "lightgrey",
    grand_summary_row.background.color = "darkgrey")
```

:::

::: {.panel}

#### Biological replicates (per timepoint)

```{r}
bio_reps_tbl <- as.data.frame(colData(sce)) |>
  dplyr::select(timepoint, cell_line, biological_replicate) |>
  dplyr::group_by(timepoint, cell_line) |>
  dplyr::distinct() |>
  dplyr::count() |>
  dplyr::group_by(timepoint)

gt(
  bio_reps_tbl,
  caption = md(
    "Number of biological replicates per `cell_line`-`timepoint` combination.")) |>
  fmt_number(columns = n, decimals = 0) |>
  summary_rows(
    columns = n, 
    fns = list(subtotal ~ sum(.)), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  grand_summary_rows(
    columns = n, 
    fns = total ~ sum(.), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  tab_options(
    summary_row.background.color = "lightgrey",
    grand_summary_row.background.color = "darkgrey")
```

:::

:::::

Note that all samples have been run in technical duplicate.
The `Day_3` and `Day_6` samples were originally plated together on one 96-well plate (`Plate A`) while the `Day_9` and `Day_12` were originally plated together on another 96-well plate (`Plate B`).

We will retain the negative control 'empty' libraries mini-bulk libraries for QC purposes.

## Incorporating gene-based annotation

We obtain gene-based annotations, such as the chromosome, using the information in the GFF file, `PlasmoDB-51_Pfalciparum3D7.gff`^[This file was originally supplied by Danielle Clucas as part of the `C122_Clucas` project].

**TODO** Move/remove these notes?

- The GFF seemingly doesn't include some simple/useful information like gene name or symbol. 
  - E.g., `PF3D7_0222700` is `RIF` or `rifin` according to https://plasmodb.org/plasmo/app/search?q=PF3D7_0222700 but that's not in the GFF file (actually, it is in the value of the `description` tag in the `attribute` field but the `makeTxDbFromGFF()` doesn't parse this field).
- I tried using a BioC resource, but there are many features in the resulting SCE with the same `GENENAME`, e.g., `rowData(sce)[which(any(rowData(sce)$GENENAME == "rifin (RIF)")), ]` (**TODO** this code doesn't work because the BioC resource isn't available).

```{r}
ids <- rownames(sce)

library(GenomicFeatures)

txdb <- makeTxDbFromGFF(
  here(
    "extdata", 
    "PlasmoDB-51_Pfalciparum3D7",
    "PlasmoDB-51_Pfalciparum3D7.gff"))

txdb_columns <- columns(txdb)
txdb_columns <- setNames(txdb_columns, txdb_columns)
txdb_df <- DataFrame(
  lapply(txdb_columns, function(column) {
    mapIds(
      x = txdb, 
      # NOTE: Need to remove gene version number prior to lookup.
      keys = gsub("\\.[0-9]+$", "", ids),
      keytype = "GENEID",
      column = column,
      multiVals = "CharacterList")
  }),
  row.names = ids)

rowData(sce) <- txdb_df
```

```{r}
# Some useful gene sets
mito_set <- rownames(sce)[any(rowData(sce)$TXCHROM == "Pf3D7_MIT_v3")]
pseudogene_set <- rownames(sce)[
  any(rowData(sce)$TXTYPE == "pseudogenic_transcript")]
ribo_set <- union(
  rownames(sce)[any(rowData(sce)$TXTYPE == "rRNA")],
  # NOTE: Include mRNA that are ribosomal protein genes.
  rownames(sce)[
    any(grepl("ribosomal", rowData(sce)$GENENAME)) &
    any(grepl("protein", rowData(sce)$GENENAME))])
```

# Read mapping metrics

## Motivation

We aimed to sequence roughly **TODO** How many million reads per technical replicate and for the majority of these reads would be exonic.

## Analysis

```{r}
library(scPipe)
sce$nreads <- apply(QC_metrics(sce_deduped)[colnames(sce), ], 1, sum)
```

Figure \@ref(fig:nreads) - \@ref(fig:intronic) shows that we generated a median of `r number(median(sce$nreads[sce$sample_type != "empty"]) / 1e6, accuracy = 0.1)` million reads per sample with a median `r percent(median((sce$mapped_to_exon / sce$nreads)[sce$sample_type != "empty"]))` of these exonic and a median `r percent(median((sce$mapped_to_intron / sce$nreads)[sce$sample_type != "empty"]))` of these intronic

::::: {.panelset}

::: {.panel}

### Number of reads

```{r}
#| nreads, 
#| fig.cap = "Number of reads generated per technical replicate. The dashed
#|    horizontal line denotes the median across all samples."

plotColData(
  sce, 
  y = "nreads",
  x = "biological_replicate",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  colour_by = "cell_line",
  theme_size = 8) +
  scale_y_log10(limits = c(1, NA)) +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  geom_hline(
    yintercept = median(sce$nreads[sce$sample_type != "empty"]), 
    lty = 2) +
  annotation_logticks(
    sides = "l",
    short = unit(0.06, "cm"),
    mid = unit(0.12, "cm"),
    long = unit(0.18, "cm")) +
  guides(colour = "none") +
  panel_border()
```

:::

::: {.panel}

### Exonic %

```{r}
#| exonic, 
#| fig.cap = "Percentage of reads that are exonic per sample. The dashed 
#|    horizontal line denotes the median across all samples."

plotColData(
  sce, 
  y = I(sce$mapped_to_exon / sce$nreads), 
  x = "biological_replicate",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  colour_by = "cell_line",
  theme_size = 8) +
  ylab("Percentage exonic") +
  geom_hline(
    yintercept = 
      median((sce$mapped_to_exon / sce$nreads)[sce$sample_type != "empty"]),
    lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  panel_border() +
  scale_y_continuous(labels = scales::percent, limits = c(0, 1))
```

:::

::: {.panel}

### Intronic %

```{r}
#| intronic, 
#| fig.cap = "Percentage of reads that are intronic per sample. The dashed 
#|    horizontal line denotes the median across all samples."

plotColData(
  sce, 
  y = I(sce$mapped_to_intron / sce$nreads), 
  x = "biological_replicate",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  colour_by = "cell_line",
  theme_size = 8) +
  ylab("Percentage intronic") +
  geom_hline(
    yintercept = 
      median((sce$mapped_to_intron / sce$nreads)[sce$sample_type != "empty"]),
    lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  panel_border() +
  scale_y_continuous(labels = scales::percent, limits = c(0, 1))
```

:::

:::::

**TODO** Re-write
We observe that `Sample 18` (`LCE658`) and `Sample 25`, `Sample 26`, `Sample 27`,  `Sample 28`, and one of the replicates of `Sample 30` (`LCE659`),  all `CD3+CD1aTet+CD4+` samples, have notably fewer reads than other samples.

## Summary

**TODO** Re-write

We achieved our aim of sequencing 5 million reads/sample, although only 1/3 of the reads are exonic.
There is some notable sample-specific variation in the number of reads generated.

**Henceforth, we only use the exonic reads.**
Although the intronic reads are potentially useful, to do so would require substantial changes to the data analysis workflow and additional analysis.

# Have we sequenced enough?

## Motivation

SCORE's mini-bulk protocol is still being finalised and some technical questions remain.
In particular, we want to know if we have sequenced enough to answer the biological questions of interest.

One way of estimating if we have sequenced enough uses a metric called 'sequencing saturation'.
10x Genomics have some useful information about sequencing saturation available [here](https://kb.10xgenomics.com/hc/en-us/articles/115005062366-What-is-sequencing-saturation-).
In particular,

>  Sequencing saturation is a measure of the fraction of library complexity that was sequenced in a given experiment. The inverse of the sequencing saturation can be interpreted as the number of additional reads it would take to detect a new transcript. ... Sequencing saturation is dependent on the library complexity and sequencing depth. Different cell types will have different amounts of RNA and thus will differ in the total number of different transcripts in the final library (also known as library complexity). ... As sequencing depth increases, more genes are detected, but this reaches saturation at different sequencing depths depending on cell type. ... Sequencing depth also affects sequencing saturation; generally, the more sequencing reads, the more additional unique transcripts you can detect. However, this is limited by the library complexity.

> This naturally leads to the question of ['how much sequencing saturation should I aim for?'](https://kb.10xgenomics.com/hc/en-us/articles/115002474263-How-much-sequencing-saturation-should-I-aim-for-), which very much depends on the goals of the experiment.

For this experiment, where we wish to assess differential expression between experimental groups, we will likely want quite high sequencing saturation.

## Analysis

To begin, we simply examine the number of reads sequenced/sample.

```{r}
reads_ls <- log10(colSums(assay(sce, "read_counts")))
```

Figure \@ref(fig:read-library-size) plots the distribution of the number of reads mapped to exons in each sample^[I.e. the 'library size' when using read counts].

```{r}
#| read-library-size, 
#| fig.cap = "Distribution of the number of reads mapped to exons in each 
#|    sample."

# TODO: Stratify by sample_type (if still including empties)
plot(
  density(reads_ls),
  xlab = expression(log[10](n[reads])),
  ylab = "density",
  xlim = range(reads_ls),
  main = "")
```

We estimate the sequencing saturation using [10x Genomics' formula](https://kb.10xgenomics.com/hc/en-us/articles/115003646912-How-is-sequencing-saturation-calculated-), 

$$
1 - (n_{deduped reads} / n_{reads})
$$
where:

- $n_{deduped reads}$ = Number of unique (valid cell-barcode, valid UMI, gene)-combinations among confidently mapped reads
- $n_{reads}$ = Total number of confidently mapped, valid cell-barcode, valid UMI reads

```{r}
saturation <- 1 - 
  (colSums(assay(sce, "UMI_counts")) / colSums(assay(sce, "read_counts")))
```

Figure \@ref(fig:saturation) shows that almost all samples are sequenced to near-total saturation.

```{r}
#| saturation, 
#| fig.cap = "Distribution of the sequencing saturation."

par(mfrow = c(1, 1))
plot(
  density(
    saturation,
    from = 0,
    to = 1),
  xlab = "saturation",
  ylab = "density",
  xlim = c(0, 1),
  main = "Sequencing saturation")
```

## Summary

These results show that the libraries are sequenced to near-saturation.

One way to think of sequencing saturation is [provided by 10x Genomics](https://kb.10xgenomics.com/hc/en-us/articles/115002474263-How-much-sequencing-saturation-should-I-aim-for-):

> The inverse of the sequencing saturation can be interpreted as roughly the number of new transcripts you expect to find with one new read. If sequencing saturation is at 50%, it means that every 2 new reads will result in 1 new UMI count (unique transcript) detected. In contrast, 90% sequencing saturation means that 10 new reads are necessary to obtain one new UMI count. If the sequencing saturation is high, additional sequencing would not recover much new information for the library.

At this stage, it is not necessary to perform additional sequencing of the library.

# UMI counts vs. read counts

## Motivation

A unique feature of SCORE's 'mini-bulk' RNA-sequencing protocol is the incorporation of unique molecular identifiers (UMIs) into the library preparation; an ordinary bulk RNA-seq protocol does not incorporate UMIs.

UMIs are commonly used in single-cell RNA-sequencing protocols, such as the CEL-Seq2 protocol from which the mini-bulk protocol is adapted.
UMIs are molecular tags that are used to detect and quantify unique mRNA transcripts.
In this method, mRNA libraries are generated by fragmentation and reverse-transcribed to cDNA.
Oligo(dT) primers with specific sequencing linkers are added to the cDNA.
Another sequencing linker with a 6 bp random label and an index sequence is added to the 5' end of the template, which is amplified and sequenced.

<aside>
This explanation is adapted from [https://sapac.illumina.com/science/sequencing-method-explorer/kits-and-arrays/umi.html](https://sapac.illumina.com/science/sequencing-method-explorer/kits-and-arrays/umi.html).
</aside>

The UMI count is always less than or equal to the read count and a UMI count of zero also implies a read count of zero.

Pros of using UMIs:

- Can sequence unique mRNA transcripts
- Can detect transcripts occurring at low frequencies
- Transcripts can be quantified based on sequencing reads specific to each barcode

Cons of using UMIs:

- SCORE's mini-bulk protocol uses a $k=6$ bp UMI^[The choice of a 6 bp UMI in the mini-bulk protocol is because it is adapted from SCORE's CEL-Seq2 single-cell RNA-sequencing protocol. With scRNA-seq data it is very rare to observe more than $4^k = 4^6 = 4096$ unique molecules for any one gene.] and so (theoretically) the maximum UMI count for each gene is $4^6 = 4096$.
- There is therefore a risk that highly expressed genes may have their expression measurements artificially truncated, particularly if the sample is deeply sequenced.

To investigate whether expression measurements are being 'truncated' in this dataset, and decide whether to use the UMI counts or the read counts, we generated and now analyse two count matrices:

1. UMI counts (i.e. deduplicating UMI counts)
2. Read counts (i.e. not deduplicating UMI counts, equivalent to ignoring the UMIs)

## Analysis

```{r}
n <- apply(assay(sce, "read_counts"), 1, function(x) sum(x > 4 ^ 6))
g <- names(n[n > 0])
```

Figure \@ref(fig:read-distribution) plots the distribution of the logarithm of the read counts.
From this we see that the vast majority of read counts are small. 
In fact:

- `r percent(sum(as.vector(assay(sce, "read_counts")) == 0) / prod(dim(sce)), accuracy = 0.1)` of read counts are 0
- 95% of the read counts are no greater than `r number(quantile(as.vector(assay(sce, "read_counts")), 0.95), big.mark = ",")` 
- 99% of the read counts are no greater than `r number(quantile(as.vector(assay(sce, "read_counts")), 0.99), big.mark = ",")` 
- 99.9% of the read counts are no greater than `r number(quantile(as.vector(assay(sce, "read_counts")), 0.999), big.mark = ",")`

```{r}
#| read-distribution, 
#| fig.cap = "Distribution of the logarithm of the read counts as density plot 
#|    (left) and empirical cumulative distribution function (right). A count of 
#|    1 is added to each UMI count to avoid taking the logarithm of zero. The 
#|    orange vertical line denotes $4^6 = 4096$.", 
#| fig.asp = 1 / 2

x <- as.vector(assay(sce, "read_counts")) + 1L
par(mfrow = c(1, 2), cex = 0.5)
plot(
  density(log2(x), from = min(log2(x)), to = max(log2(x))),
  xlab = expression(log[2](reads + 1)),
  main = "",
  ylab = "density")
abline(v = log2(4 ^ 6), col = "orange")
plot(
  ecdf(log2(x)), 
  xlim = range(log2(x)),
  main = "",
  xlab = expression(log[2](reads + 1)),
  ylab = "cumulative density")
abline(v = log2(4 ^ 6), col = "orange")
```

Only `r percent(sum(as.vector(assay(sce, "read_counts")) > 4^6) / prod(dim(sce)), accuracy = 0.01)` of read counts exceed the $4^6 = 4096$ threshold.
However there are `r number(length(g), big.mark = ",")` genes for which at least one sample exceeds the $4^6=4096$ threshold; these genes are shown in the table below.
If we were to use the UMI counts, the genes in this list may have their expression measurements artificially truncated in those samples where the number of copies of the transcript exceed the $4^6=4096$ threshold.

This table shows that many of these genes are mitochondrial and ribosomal protein genes.

```{r}
read_e <- as.matrix(assay(sce, "read_counts")[g, ])
umi_e <- as.matrix(assay(sce, "UMI_counts")[g, ])
high_count_tbl <- tibble::tibble(
  gene = g,
  read_median_count = matrixStats::rowMedians(read_e),
  read_exceed_sum = matrixStats::rowSums2(read_e > 4 ^ 6),
  read_exceed_percent = read_exceed_sum / ncol(sce),
  umi_median_count = matrixStats::rowMedians(umi_e),
  umi_exceed_sum = matrixStats::rowSums2(umi_e > 4 ^ 6),
  umi_exceed_percent = umi_exceed_sum / ncol(sce)) %>%
  dplyr::arrange(desc(read_exceed_sum))
sketch <- htmltools::withTags(
  table(
    class = "display",
    thead(
      tr(
        th(rowspan = 2, "gene"),
        th(colspan = 3, "reads"),
        th(colspan = 3, "UMIs")
      ),
      tr(
        lapply(rep(c("median count", "N > 4096", "% > 4096"), 2), th)
      )
    )
  ))

DT::datatable(
  high_count_tbl, 
  caption = "Genes for which any sample has a read count exceeding the 4096 threshold and summaries of the corresponding read and UMI counts, namely: the median count ('median count'); the number of samples for which the counts exceed the threshold ('N > 4096'); and the percentage of samples for which the counts exceed the threshold ('% > 4096').",
  container = sketch,
  rownames = FALSE) %>%
  DT::formatPercentage(
    columns = c("read_exceed_percent", "umi_exceed_percent"),
    digits = 1) %>%
  DT::formatRound(
    columns = c("read_median_count", "umi_median_count"),
    digits = 0)
```

Figure \@ref(fig:scatterplot-and-ma-plot) plots the relationship between UMI counts and read counts for all genes and samples.
There are a few notable points about this figure:

1. The UMI counts and read counts are very strongly associated.
2. The log-fold change between the read counts and the UMI counts can be large, indicating the UMI counts are likely removing substantial PCR amplification noise.
3. The log-fold changes between the read counts and the UMI counts are larger on average for more highly expressed genes. The variation in the log-fold change is larger for the lowly expressed genes.

```{r}
#| scatterplot-and-ma-plot, 
#| fig.cap = "Scatterplot of the logarithm of the UMI and read counts (top)
#|    and logCPM of the UMI and read counts (bottom) for all genes and samples 
#|    (left) and mean-difference plot of the same data (right). The correlation
#|    in the scatterplot is reported below the x-axis label. Genes that are 
#|    ribosomal protein genes subunits are highlighted in orange and 
#|    mitochondrial genes in blue. The red line is a trend fitted to the
#|    mean-differences.", 
#| fig.asp = 1

x <- log2(as.vector(assay(sce, "UMI_counts")) + 1)
y <- log2(as.vector(assay(sce, "read_counts")) + 1)
m <- (x + y) / 2
d <- y - x
g <- rep(rownames(sce), ncol(sce))
# NOTE: Only showing unique points for plotting speed.
i <- !duplicated(paste0(x, ".", y))
X <- edgeR::cpm(assay(sce, "UMI_counts"), log = TRUE)
Y <- edgeR::cpm(assay(sce, "read_counts"), log = TRUE)
M <- (X + Y) / 2
D <- y - x
G <- g
# NOTE: Only showing unique points for plotting speed.
I <- !duplicated(paste0(x, ".", y))
par(mfrow = c(2, 2))
plotWithHighlights(
  x = x[i],
  y = y[i],
  status = ifelse(g[i] %in% ribo_set, 1, ifelse(g[i] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  sub = paste0("r = ", number(cor(x, y), accuracy = 0.001)),
  xlab = expression(log[2](UMIs + 1)),
  ylab = expression(log[2](reads + 1)))
abline(a = 0, b = 1, lty = 2, col = "grey")
plotWithHighlights(
  x = m[i] / 2,
  y = d[i],
  pch = ".",
  status = ifelse(g[i] %in% ribo_set, 1, ifelse(g[i] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  xlab = "Average log-(count+1)",
  ylab = "logFC (reads vs. UMIs)",
  ylim = c(-max(abs(c(d, D))), max(abs(c(d, D)))))
abline(h = 0, lty = 2, col = "grey")
l <- lowess(m, d, f = 0.3)
lines(l, col = "red", lwd = 2)
plotWithHighlights(
  x = X[I],
  y = Y[I],
  status = ifelse(G[I] %in% ribo_set, 1, ifelse(G[I] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  sub = paste0(
    "r = ", 
    number(cor(as.vector(X), as.vector(Y)), accuracy = 0.001)),
  xlab = expression(logCPM(UMIs)),
  ylab = expression(logCPM(reads)))
abline(a = 0, b = 1, lty = 2, col = "grey")
plotWithHighlights(
  x = M[I],
  y = D[i],
  status = ifelse(G[I] %in% ribo_set, 1, ifelse(G[I] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  xlab = "Average logCPM",
  ylab = "logFC (reads vs. UMIs)",
  ylim = c(-max(abs(c(d, D))), max(abs(c(d, D)))))
abline(h = 0, lty = 2, col = "grey")
l <- lowess(M, D, f = 0.3)
lines(l, col = "red", lwd = 2)
```

```{r}
X <- edgeR::cpm(assay(sce, "UMI_counts"), log = TRUE)
Y <- edgeR::cpm(assay(sce, "read_counts"), log = TRUE)
cor_j <- diag(cor(X, Y))
# NOTE: Splitting up the cor() computations is a hack to improve speed whilst 
#       keeping memory usage somewhat under control.
b <- 1000
s <- seq(1, by = b, to = nrow(sce))
e <- pmin(s + b - 1, nrow(sce))
cor_i <- unlist(
  Map(
    f = function(ss, ee ) diag(cor(t(X[ss:ee, ]), t(Y[ss:ee, ]))),
    ss = s,
    ee = e))
```

Rather than looking at all samples and all genes at once, we can also examine the relationship between UMI counts and read counts within a single sample across genes (Figure \@ref(fig:within-sample-cors)) and within a single gene across samples (Figure \@ref(fig:within-gene-cors)).
These figures show that the UMI counts and read counts are highly correlated across both samples (median = `r number(median(cor_j, na.rm = TRUE), accuracy = 0.001)`, median absolute deviation = `r number(mad(cor_j, na.rm = TRUE), accuracy = 0.001)`) and genes (median = `r number(median(cor_i, na.rm = TRUE), accuracy = 0.001)`, median absolute deviation = `r number(mad(cor_i, na.rm = TRUE), accuracy = 0.001)`).

**TODO** Within-sample and within-gene might have their names swapped.

::::: {.panelset}

::: {.panel}

### Within-sample

```{r}
#| within-sample-cors, 
#| fig.cap = "Association between UMI counts and read counts for each gene 
#|    within each sample. The first 8 panels are scatter plots of the UMI 
#|    counts and read counts for each gene for the samples with the 3 lowest
#|    correlations, 2 middlemost correlations, and 3 highest correlations. The
#|    correlation in the scatterplot is reported below each panel. Genes that 
#|    are ribosomal protein genes subunits are highlighted in orange and
#|    mitochondrial genes in blue. The final panel is the distribution of these
#|    correlations across all samples.",
#| fig.asp = 1

par(mfrow = c(3, 3), cex = 0.5)
# TODO: revise jj if dropping empties
jj <- names(sort(cor_j)[c(1:3, 187:188, 374:376)])
for (j in jj) {
  g <- rownames(sce)
  plot(
    x = X[, j],
    y = Y[, j],
    pch = ".",
    cex = ifelse(g %in% c(ribo_set, mito_set), 5, 1),
    col = ifelse(
      g %in% ribo_set, "orange",
      ifelse(g %in% mito_set, "dodgerBlue", "black")),
    sub = paste0("r = ", number(cor_j[j], accuracy = 0.001)),
    xlab = "logCPM(UMIs)",
    ylab = "logCPM(reads)",
    main = j,
    xlim = range(x),
    ylim = range(y))
  abline(a = 0, b = 1, col = "grey", lty = 2)
}
plot(
  density(cor_j, na.rm = TRUE, from = -1, to = 1),
  main = "All samples", 
  xlab = expression(r[p]))
```

:::

::: {.panel}

### Within-gene

```{r}
#| within-gene-cors, 
#| fig.cap = "Association between UMI counts and read counts for each sample 
#|    within each gene. The first 8 panels are scatter plots of the UMI counts
#|    and read counts for each sample for the genes with the 3 lowest 
#|    correlations, 2 middlemost correlations, and 3 highest correlations. The 
#|    correlation in the scatterplot is reported below each panel. Genes that 
#|    are ribosomal protein genes subunits are highlighted in orange and 
#|    mitochondrial genes in blue. The final panel is the distribution of 
#|    these correlations across all genes.",
#| fig.asp = 1

par(mfrow = c(3, 3), cex = 0.5)
ii <- names(sort(cor_i)[c(1:3, 2861:2862, 5722:5724)])
for (i in ii) {
  g <- i
  plot(
    x = X[i, ],
    y = Y[i, ],
    pch = 16,
    col = ifelse(
      g %in% ribo_set, "orange",
      ifelse(g %in% mito_set, "dodgerBlue", "black")),
    sub = paste0("r = ", number(cor_i[i], accuracy = 0.001)),
    xlab = "logCPM(UMIs)",
    ylab = "logCPM(reads)",
    main = i,
    xlim = range(X),
    ylim = range(Y))
  abline(a = 0, b = 1, col = "grey", lty = 2)
}
plot(
  density(cor_i, na.rm = TRUE, from = -1, to = 1),
  main = "All genes", 
  xlab = expression(r[p]))
```

:::

:::::

## Summary

The ultimate aim of this analysis is to perform a differential expression (DE) analysis. 
On the one hand, a DE analysis is more powerful when there are more counts available, which is where the read counts are favoured.
On the other hand, a DE analysis may be biased if these counts arise through PCR duplicates, which is where the deduplicated UMI counts are favoured.
The choice between using the read counts or the UMI counts in the DE analysis is therefore a trade-off between these two choices.

**For now, we defer our choice of read counts vs. UMI counts, but the remainder of this preprocessing report uses (exonic) read counts**.

# Quality control of cells

## Defining the quality control metrics

Low-quality cells need to be removed to ensure that technical effects do not distort downstream analysis results.
We use several quality control (QC) metrics to measure the quality of the cells:

- `sum`: This measures the library size of the samples, which is the total sum of counts across genes. We want samples to have high library sizes as this means more RNA has been successfully captured during library preparation. 
- `detected`: This is the number of expressed features^[The number of expressed genes refers to the number of genes which have non-zero counts (ie. they have been identified in the cell at least once)] in each cell. Cells with few expressed features are likely to be of poor quality, as the diverse transcript population has not been successful captured. 
- `altexps_ERCC_detected`: This measures the proportion of reads which are mapped to spike-in transcripts relative to the library size of each cell. High proportions are indicative of poor-quality cells, where endogenous RNA has been lost during processing (e.g., due to cell lysis or RNA degradation). 
The same amount of spike-in RNA to each cell, so an enrichment in spike-in counts is symptomatic of loss of endogenous RNA.
- `subsets_Mito_percent`: This measures the proportion of reads which are mapped to mitochondrial RNA. If there is a higher than expected proportion of mitochondrial RNA this is often symptomatic of a cell which is under stress and is therefore of low quality and will not be used for the analysis. 
- `subsets_Ribo_percent`: This measures the proportion of UMIs which are mapped to ribosomal protein genes. If there is a higher than expected proportion of ribosomal protein gene expression this is often symptomatic of a cell which is of compromised quality and we may want to exclude it from the analysis. 

```{r}
#| results = "hide"

is_mito <- rownames(sce) %in% mito_set
summary(is_mito)
is_ribo <- rownames(sce) %in% ribo_set
summary(is_ribo)
sce <- addPerCellQC(
  sce, 
  subsets = list(Mito = which(is_mito), Ribo = which(is_ribo)),
  assay.type = "read_counts")
```

## Visualizing the QC metrics

Figures \@ref(fig:qcplot-by-sample-gex-sum) - \@ref(fig:qcplot-by-sample-gex-ribo) compare the QC metrics of the mini-bulk samples.
We observe that `Sample 18` (`LCE658`) and `Sample 25`, `Sample 26`, `Sample 27`,  `Sample 28`, and one of the replicates of `Sample 30` (`LCE659`), all `CD3+CD1aTet+CD4+` samples, have notably fewer reads than other samples, fewer genes detected, and a high percentage of reads mapping to mitochondrial genes.
These samples are all of low quality and we may need to remove them in downstream analyses.

These figures show that the majority of mini-bulk samples are good-quality with:

- The median library size is around `r number(median(sce$sum), accuracy = 1000, big.mark = ",")`.
- The median number of genes detected is around `r number(median(sce$detected), accuracy = 100, big.mark = ",")`.
- The median percentage of reads that are mapped to mitochondrial RNA is around  `r percent(median(sce$subsets_Mito_percent), scale = 1)`.
- The median percentage of reads that are mapped to ribosomal protein genes is around  `r percent(median(sce$subsets_Ribo_percent), scale = 1)`.
- The median percentage of reads that are mapped to ERCC spike-ins is around  `r percent(median(sce$altexps_ERCC_percent), scale = 1)`.

::::: {.panelset}

::: {.panel}

#### Sum

```{r}
#| qcplot-by-sample-gex-sum,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each sample 
#|   in the dataset. Each point represents a cell and is coloured according to 
#|   the legend."

p_sum <- plotColData(
  sce, 
  y = "sum",
  x = "biological_replicate",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  theme_size = 8) +
  geom_hline(
    yintercept = median(sce$sum[sce$sample_type != "empty"]), 
    lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  scale_y_continuous(labels = comma) +
  panel_border()

p_sum + ggtitle("GEX: Library size")
```

:::

::: {.panel}


#### Sum (log scale)

```{r}
#| qcplot-by-sample-gex-log-sum,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each sample 
#|   in the dataset. Each point represents a cell and is coloured according to 
#|   the legend."

p_sum_log <- p_sum + 
  scale_y_log10(limits = c(1, NA), labels = comma) +
  annotation_logticks(
    sides = "l",
    short = unit(0.03, "cm"),
    mid = unit(0.06, "cm"),
    long = unit(0.09, "cm"))

p_sum_log + ggtitle("GEX: Library size (log scale)")
```

:::

::: {.panel}

#### Detected

```{r}
#| qcplot-by-sample-gex-detected,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each sample 
#|   in the dataset. Each point represents a cell and is coloured according to 
#|   the legend."

p_detected <- plotColData(
  sce, 
  y = "detected",
  x = "biological_replicate",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  theme_size = 8) +
  geom_hline(
    yintercept = median(sce$detected[sce$sample_type != "empty"]), 
    lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  scale_y_continuous(labels = comma) +
  panel_border()

p_detected + ggtitle("GEX: Number of genes detected")
```

:::

::: {.panel}

#### Detected (log scale)

```{r}
#| qcplot-by-sample-gex-log-detected,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each sample 
#|   in the dataset. Each point represents a cell and is coloured according to 
#|   the legend."

p_detected_log <- p_detected + 
  scale_y_log10(limits = c(1, NA), labels = comma) +
  annotation_logticks(
    sides = "l",
    short = unit(0.03, "cm"),
    mid = unit(0.06, "cm"),
    long = unit(0.09, "cm"))

p_detected_log + ggtitle("GEX: Number of genes detected (log scale)")
```

:::

::: {.panel}

#### Mitochondrial %

```{r}
#| qcplot-by-sample-gex-mito,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each sample 
#|   in the dataset. Each point represents a cell and is coloured according to 
#|   the legend."

p_mito <- plotColData(
  sce, 
  y = "subsets_Mito_percent",
  x = "biological_replicate",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  theme_size = 8) +
  geom_hline(
    yintercept = median(sce$subsets_Mito_percent[sce$sample_type != "empty"]), 
    lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  scale_y_continuous(labels = comma) +
  scale_y_continuous(labels = function(x) percent(x, scale = 1)) +
  panel_border()

p_mito + ggtitle("GEX: Percentage mitochondrial expression")
```

:::

::: {.panel}

#### Ribosomal %

```{r}
#| qcplot-by-sample-gex-ribo,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each sample 
#|   in the dataset. Each point represents a cell and is coloured according to 
#|   the legend."

p_ribo <- plotColData(
  sce, 
  y = "subsets_Ribo_percent",
  x = "biological_replicate",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  theme_size = 8) +
  geom_hline(
    yintercept = median(sce$subsets_Ribo_percent[sce$sample_type != "empty"]), 
    lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  scale_y_continuous(labels = comma) +
  scale_y_continuous(labels = function(x) percent(x, scale = 1)) +
  panel_border()

p_ribo + ggtitle("GEX: Percentage ribosomal expression")
```

:::

:::::

**TODO** Very high ribo%; why?

## Identifying outliers by each metric

Outliers are defined based on the median absolute deviation (MADs) from the median value of each metric across all cells. 
We remove small and large outliers for the library size and the number of expressed features, and large outliers for the spike-in proportions and mitochondrial gene expression proportions.
Removal of low-quality cells is then performed by combining the filters for all of the metrics.

```{r}
libsize_drop <- isOutlier(
  metric = sce$sum, 
  nmads = 3,
  type = "lower", 
  log = TRUE)
feature_drop <- isOutlier(
  metric = sce$detected,
  nmads = 3, 
  type = "lower", 
  log = TRUE)
mito_drop <- isOutlier(
  metric = sce$subsets_Mito_percent, 
  nmads = 3, 
  type = "higher")
ribo_drop <- isOutlier(
  metric = sce$subsets_Ribo_percent, 
  nmads = 3, 
  type = "higher")
```

The following table summarises the QC cutoffs:

```{r}
libsize_drop_df <- data.frame(
  cutoff = attributes(libsize_drop)$thresholds["lower"])
feature_drop_df <- data.frame(
  cutoff = attributes(feature_drop)$thresholds["lower"])
mito_drop_df <- data.frame(
  cutoff = attributes(mito_drop)$thresholds["higher"])
ribo_drop_df <- data.frame(
  cutoff = attributes(ribo_drop)$thresholds["higher"])
qc_cutoffs_df <- cbind(
    libsize_drop_df,
    feature_drop_df, 
    mito_drop_df, 
    ribo_drop_df)
colnames(qc_cutoffs_df) <- c(
  "total counts", "total features", "%mito", "%ribo")
knitr::kable(qc_cutoffs_df, caption = "QC cutoffs", digits = 1)
```

**We would typically remove outliers (e.g., small outliers for the library size and the number of expressed features, large outliers for mitochondrial gene expression percentage) at this stage.**
However, we opt to retain all samples for the time being.
The following table highlights samples that would typically exclude as outliers by this criteria:

```{r}
keep <- !(libsize_drop | feature_drop | mito_drop)
x <- cbind(
  data.frame(sample = colnames(sce), keep = keep),
  colData(sce)[
    ,
    c("sample", "sum", "detected", "subsets_Mito_percent")])
row.names(x) <- NULL
DT::datatable(
  x[order(keep), ],
  caption = "Quality control metrics including library size (`sum`) and number of genes detected (`keep`) for each replicate. Each replicate is annotated by whether it would be kept or excluded by the typical quality control procedures (`keep`).",
  rownames = FALSE) |>
  DT::formatRound(c("subsets_Mito_percent"))
```

## Summary

We have opted not to exclude any replicates at this stage.
However, we have identified some replicates with unusually small library sizes and number of genes detected and unusually high mitochondrial gene expression percentage compared to the other samples.
We will keep an eye on these replicates and may later remove some of these.

# Examining gene-level metrics

## Inspecting the most highly expressed genes

Figure \@ref(fig:topgenes) shows the most highly expressed genes across all samples.
Many of them are mitochondrial genes, matching what we've already seen in the QC metrics, and ribosomal protein genes, which commonly are amongst the most highly expressed genes in mini-bulk data and also consistent with some samples having mostly mitochondrial genes expressed.
Figure \@ref(fig:topgenes-filtered) shows the most highly expressed endogenous genes after excluding the mitochondrial and ribosomal protein genes, where we observe genes that are more relevant to the cell types and biology we are trying to study.

::::: {.panelset}

::: {.panel}

### All genes

```{r}
#| topgenes, 
#| fig.asp = 1, 
#| fig.cap = "Percentage of total counts assigned to the top 50 most 
#|    highly-abundant features in the combined data set. For each feature, each 
#|    bar represents the percentage assigned to that feature for a single cell,
#|    while the circle represents the average across all cells."

# TODO: Highest expressed gene is a rRNA (I think).
plotHighestExprs(sce, n = 50, exprs_values = "read_counts")
```

:::

::: {.panel}

### Filtered genes

```{r}
#| topgenes-filtered, 
#| fig.asp = 1, 
#| fig.cap = "Percentage of total counts assigned to the top 50 most 
#|    highly-abundant features in the combined data set. For each feature, 
#|    each bar represents the percentage assigned to that feature for a single 
#|    cell, while the circle represents the average across all cells. Bars are
#|    coloured by the total number of expressed features in each cell, while 
#|    circles are coloured according to whether the feature is labelled as a 
#|    control feature."

plotHighestExprs(
  sce,
  drop_features = rownames(sce) %in% c(mito_set, ribo_set),
  n = 50,
  exprs_values = "read_counts")
```

:::

:::::

# MDS plot

We conclude with some MDS visualisations of the data.

```{r}
assay(sce, "logCPM_reads") <- edgeR::cpm(assay(sce, "read_counts"), log = TRUE)
dec <- scran::modelGeneVar(sce, assay.type = "logCPM_reads")
hvg <- scran::getTopHVGs(dec, n = 1000)
sce <- runMDS(sce, subset_row = hvg, exprs_values = "logCPM_reads")
mds_df <- makePerCellDF(sce)
bg <- dplyr::select(
  mds_df, 
  -sample_type, -original_plate, -cell_line, -timepoint)
```

::::: {.panelset}

::: {.panel}

### Sample type

```{r}
#| mds-by-sample-type, 
#| fig.cap = "MDS plot of the dataset. Each point represents a sample and 
#|    is coloured by `sample_type` with each panel highlighting droplets from 
#|    a particular `sample_type`.",
#| fig.asp = 1 / 2

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 1) +
  geom_point(aes(colour = sample_type), alpha = 1, size = 2) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_grid(~ sample_type) +
  guides(colour = "none") +
  ggtitle("Faceted by sample_type") +
  panel_border()
```

:::

::: {.panel}

### Original plate

```{r}
#| mds-by-original-plate, 
#| fig.cap = "MDS plot of the dataset. Each point represents a sample and 
#|    is coloured by `original_plate` with each panel highlighting droplets 
#|    from a particular `original_plate`.",
#| fig.asp = 2 / 2

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 1) +
  geom_point(aes(colour = original_plate), alpha = 1, size = 2) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ original_plate, ncol = 2) +
  guides(colour = "none") +
  ggtitle("Faceted by sample_type") +
  panel_border()
```

:::

::: {.panel}

### Cell line

```{r}
#| mds-by-cell-line, 
#| fig.cap = "MDS plot of the dataset. Each point represents a sample and 
#|    is coloured by `cell_line` with each panel highlighting droplets from 
#|    a particular `cell_line`.",
#| fig.asp = 3 / 3

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 1) +
  geom_point(aes(colour = cell_line), alpha = 1, size = 2) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ cell_line, ncol = 3) +
  guides(colour = "none") +
  ggtitle("Faceted by cell_line") +
  panel_border()
```

:::

::: {.panel}

### Timepoint

```{r}
#| mds-by-timepoint, 
#| fig.cap = "MDS plot of the dataset. Each point represents a sample and 
#|    is coloured by `timepoint` with each panel highlighting droplets from 
#|    a particular `timepoint`.",
#| fig.asp = 2 / 3

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 1) +
  geom_point(aes(colour = timepoint), alpha = 1, size = 2) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ timepoint, ncol = 3) +
  guides(colour = "none") +
  ggtitle("Faceted by timepoint") +
  panel_border()
```

:::

::: {.panel}

### Cell line + timepoint

```{r}
#| mds-by-cell-line-timepoint, 
#| fig.cap = "MDS plot of the dataset. Each point represents a sample and 
#|    is coloured by `cell_line` with each panel highlighting droplets from 
#|    a particular `cell_line`.",
#| fig.asp = 5 / 7

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.5) +
  geom_point(aes(colour = cell_line), alpha = 1, size = 1) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_grid(timepoint~ cell_line) +
  guides(colour = "none") +
  ggtitle("Faceted by cell_line + timepoint") +
  panel_border()
```

:::

::: {.panel}


### Library size

```{r}
#| mds-by-library-size, 
#| fig.cap = "MDS plot of the dataset. Each point represents a sample and 
#|    is coloured by library size (log10(`sum`)).",
#| fig.asp = 1

scater::plotMDS(
  sce,
  colour_by = data.frame(`log10(sum)` = log10(sce$sum), check.names = FALSE), 
  point_alpha = 1,
  point_size = 2)
```

:::

:::::

## Summary

Although Figures \@ref(fig:mds-by-sample-type) - \@ref(fig:mds-by-library-size) are only a preliminary summary of the data, there are few patterns worth highlighting:

**TODO** Re-write

- Some association of MDS co-ordinates and phenotype.
- Some of MDS co-ordinates with library size, i.e. low-quality samples separating out from high-quality samples.

# Concluding remarks

```{r}
# Remove some unneeded assays and reducedDims.
assay(sce, "logCPM_reads") <- NULL
reducedDims(sce) <- NULL

# Save
saveRDS(
  sce,
  here("data", "SCEs", "G000396_Danu.preprocessed.SCE.rds"),
  compress = "xz")
```

The processed *SingleCellExperiment* object is available (see [`data/SCEs/G000396_Danu.preprocessed.SCE.rds`](../data/SCEs/G000396_Danu.preprocessed.SCE.rds)).
This will be used in downstream analyses, i.e. differential expression analysis.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

</details>

# TODOs

- [ ] When to remove empties?
- [ ] QC after aggregating tech reps
- [ ] Interactive MDS plot?
- [ ] Treat the empties like empty drops, e.g., estimate ambient profile etc.
