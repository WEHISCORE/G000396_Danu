---
title: "Preprocessing the G000396 mini-bulk data set"
description: |
author:
  - name: Peter Hickey
    url: https://peterhickey.org
    affiliation: Cellular Genomics Projects Team (formerly SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/rory-bowden/4536/wehi-advanced-genomics-facility
date: "`r Sys.Date()`"
editor_options:
  chunk_output_type: console
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(scales)
library(ggplot2)
library(cowplot)
library(patchwork)
library(ggrepel)
library(gt)
library(scater)
library(limma)

knitr::opts_chunk$set(fig.path = "G000396_Danu.preprocess_files/")

# NOTE: The following is a workaround to the lack of support for tabsets in 
#       distill (see https://github.com/rstudio/distill/issues/11 and 
#       https://github.com/rstudio/distill/issues/11#issuecomment-692142414 in 
#       particular).
xaringanExtra::use_panelset()
```

# Setting up the data

We start from the count matrices created in [`code/scPipe.R`](../code/scPipe.R`), specifically the [UMI counts (a.k.a. UMI-deduplicated) data](../data/SCEs/G000396_Danu.UMI_deduped.scPipe.SCE.rds) and [read counts (a.k.a. not UMI-deduplicated) data](../data/SCEs/G000396_Danu.not_UMI_deduped.scPipe.SCE.rds).

<aside>
UMI stands for unique molecular identifier.
</aside>

```{r}
sce_deduped <- readRDS(
  here("data", "SCEs", "G000396_Danu.UMI_deduped.scPipe.SCE.rds"))
sce_not_deduped <- readRDS(
  here("data", "SCEs", "G000396_Danu.not_UMI_deduped.scPipe.SCE.rds"))

colnames(sce_not_deduped) <- sub(
  "\\.not_UMI_deduped",
  "",
  colnames(sce_not_deduped))
stopifnot(
  identical(rownames(sce_deduped), rownames(sce_not_deduped)),
  identical(colnames(sce_deduped), colnames(sce_not_deduped))) 

# Combine UMI and read counts a single SCE.
sce <- sce_deduped
assay(sce, "UMI_counts") <- assay(sce_deduped, "counts")
assay(sce, "read_counts") <- assay(sce_not_deduped, "counts")
# NOTE: Nullify some now-unrequired data.
assay(sce, "counts") <- NULL
sce$UMI_deduped <- NULL
```

We combine these into a single object^[In the terminology of Bioconductor this is called a *SingleCellExperiment* object.] containing both the UMI counts and the read counts for `r number(nrow(sce), big.mark = ",")` genes and `r number(ncol(sce), big.mark = ",")` samples.

## Experimental design

```{r}
# Initial tidying of sample metadata
sce$plate_number <- factor(sce$plate_number)
sce$well_position <- factor(
  sce$well_position,
  unlist(lapply(LETTERS[1:16], function(x) paste0(x, 1:24))))
sce$sample_type <- factor(sce$sample_type)
sce$original_plate <- factor(sce$original_plate)
sce$cell_line <- factor(
  sce$cell_line,
  levels = c("GID1KO", "GID2KO", "GID7KO", "GID8KO", "GID9KO", "WT", "N/A"))
sce$timepoint <- factor(
  sce$timepoint,
  levels = c(paste0("Day_", c(3, 6, 9, 12)), "N/A"))
sce$biological_replicate <- factor(
  sce$biological_replicate,
  levels = c(1:5, "N/A"))
sce$technical_replicate <- factor(
  sce$technical_replicate, 
  levels = c(1:2, "N/A"))
sce$sequencing_run <- factor(sce$sequencing_run)
sce$sample <- interaction(
  sce$cell_line, 
  sce$timepoint, 
  sce$biological_replicate, 
  drop = TRUE, 
  lex.order = TRUE)
sce$group <- interaction(
  sce$cell_line,
  sce$timepoint,
  lex.order = TRUE,
  drop = TRUE)
sce$cell_line_rep <- interaction(
  sce$cell_line,
  sce$biological_replicate,
  lex.order = TRUE,
  drop = TRUE)

# Some useful colours
# NOTE: First 5 colours are based on Set1
cell_line_colours <- c(
  "GID1KO" = "#e41a1c",
  "GID2KO" = "#377eb8",
  "GID7KO" = "#4daf4a",
  "GID8KO" = "#984ea3",
  "GID9KO" = "#ff7f00",
  "WT" = "black",
  "N/A" = "grey")
timepoint_colours <- setNames(
  palette.colors(nlevels(sce$timepoint), "Set2"),
  levels(sce$timepoint))
group_colours <- setNames(
  c(
    unlist(
      lapply(
        cell_line_colours[1:6],
        function(x) {
          unlist(lapply(x, colorspace::lighten, amount = seq(0, 0.75, 0.25)))
        }
      )
    ),
    "grey"),
  levels(sce$group))
```

### Introduction

This is a large and somewhat complex experiment.
There are `r number(nlevels(sce$sample) - 1, big.mark = ",")` biological samples, each done in technical duplicate for a total of `r number(sum(sce$sample_type != "empty"), big.mark = ",")` mini-bulk libraries.
There are also`r number(sum(sce$sample_type == "empty"), big.mark = ",")` negative control 'empty' libraries^[The negative control samples have `N/A` recorded for the various sample metadata.].
For now, we will retain the negative control 'empty' libraries mini-bulk libraries for QC purposes.
The tables below summarise the samples in this experiment.

<aside>
The `Day_3` and `Day_6` samples were originally plated together on one 96-well plate (`Plate A`) while the `Day_9` and `Day_12` were originally plated together on another 96-well plate (`Plate B`).
</aside>

::::: {.panelset}

::: {.panel}

#### Technical replicates

```{r}
tech_reps_tbl <- as.data.frame(colData(sce)) |>
  dplyr::group_by(cell_line, timepoint, biological_replicate) |>
  dplyr::count() |> 
  dplyr::group_by(cell_line, timepoint)

gt(
  tech_reps_tbl,
  caption = md(
    "Number of technical replicates per `cell_line`-`timepoint`-`biological_replicate` combination.")) |>
  fmt_number(columns = n, decimals = 0) |>
  summary_rows(
    columns = n, 
    fns = list(subtotal ~ sum(.)), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  grand_summary_rows(
    columns = n, 
    fns = total ~ sum(.), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  tab_options(
    summary_row.background.color = "lightgrey",
    grand_summary_row.background.color = "darkgrey")
```

:::

::: {.panel}

#### Biological replicates (per cell line)

```{r}
bio_reps_tbl <- as.data.frame(colData(sce)) |>
  dplyr::select(cell_line, timepoint, biological_replicate) |>
  dplyr::group_by(cell_line, timepoint) |>
  dplyr::distinct() |>
  dplyr::count() |>
  dplyr::group_by(cell_line)

gt(
  bio_reps_tbl,
  caption = md(
    "Number of biological replicates per `cell_line`-`timepoint` combination.")) |>
  fmt_number(columns = n, decimals = 0) |>
  summary_rows(
    columns = n, 
    fns = list(subtotal ~ sum(.)), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  grand_summary_rows(
    columns = n, 
    fns = total ~ sum(.), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  tab_options(
    summary_row.background.color = "lightgrey",
    grand_summary_row.background.color = "darkgrey")
```

:::

::: {.panel}

#### Biological replicates (per timepoint)

```{r}
bio_reps_tbl <- as.data.frame(colData(sce)) |>
  dplyr::select(timepoint, cell_line, biological_replicate) |>
  dplyr::group_by(timepoint, cell_line) |>
  dplyr::distinct() |>
  dplyr::count() |>
  dplyr::group_by(timepoint)

gt(
  bio_reps_tbl,
  caption = md(
    "Number of biological replicates per `timepoint`-`cell_line` combination.")) |>
  fmt_number(columns = n, decimals = 0) |>
  summary_rows(
    columns = n, 
    fns = list(subtotal ~ sum(.)), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  grand_summary_rows(
    columns = n, 
    fns = total ~ sum(.), 
    fmt = ~ fmt_number(., decimals = 0)) |>
  tab_options(
    summary_row.background.color = "lightgrey",
    grand_summary_row.background.color = "darkgrey")
```

:::

:::::

## Incorporating gene-based annotation

We obtain gene-based annotations, such as the chromosome, using the information in the GFF file, `PlasmoDB-66_Pfalciparum3D7.gff`.

Having quantified gene expression against the PlasmoDB gene annotation, we have PlasmoDB-style gene identifiers for the genes. 
These identifiers are used as they are unambiguous and highly stable. 
However, they are difficult to interpret compared to the gene symbols which are more commonly used in the literature.
Henceforth, we will use gene symbols (where available) to refer to genes in our analysis and otherwise use the PlasmoDB-style gene identifiers^[Some care is taken to account for missing and duplicate gene symbols; missing symbols are replaced with the PlasmoDB identifier and duplicated symbols are concatenated with the (unique) PlasmoDB identifiers.].

We also construct some useful gene sets: mitochondrial genes, ribosomal protein genes, sex chromosome genes, and pseudogenes.

```{r}
library(GenomicFeatures)

ids <- rownames(sce)

gff <- here(
  "extdata",
  "PlasmoDB-66_Pfalciparum3D7",
  "PlasmoDB-66_Pfalciparum3D7.gff")

txdb <- makeTxDbFromGFF(gff)

txdb_columns <- columns(txdb)
txdb_columns <- setNames(txdb_columns, txdb_columns)
txdb_df <- DataFrame(
  lapply(txdb_columns, function(column) {
    message(column)
    mapIds(
      x = txdb, 
      keys = ids,
      keytype = "GENEID",
      column = column,
      multiVals = "CharacterList")
  }),
  row.names = ids)

# Extract additional useful fields not retained by makeTxDbFromGFF().
gff_gr <- rtracklayer::import(gff)
i <- match(rownames(txdb_df), gff_gr$ID)
gff_df <- mcols(gff_gr)[i, c("Name", "description")]

rowData(sce) <- cbind(txdb_df, gff_df)

# Replace the row names of the SCE by the gene symbols (where available).
rownames(sce) <- uniquifyFeatureNames(
  ID = rownames(sce),
  names = vapply(rowData(sce)$Name, function(x) {
    if (length(x)) {
      x[[1]]
    } else {
      NA_character_
    }
  },
  character(1)))
```

```{r}
# Some useful gene sets
mito_set <- rownames(sce)[any(rowData(sce)$TXCHROM == "Pf3D7_MIT_v3")]
pseudogene_set <- rownames(sce)[
  any(rowData(sce)$TXTYPE == "pseudogenic_transcript")]
ribo_set <- union(
  rownames(sce)[any(rowData(sce)$TXTYPE == "rRNA")],
  # NOTE: Include mRNA that are ribosomal protein genes.
  rownames(sce)[
    any(grepl("ribosomal", rowData(sce)$GENENAME)) &
    any(grepl("protein", rowData(sce)$GENENAME))])
```

# Read mapping metrics

## Motivation

We aimed to sequence approximately 5 million reads per technical replicate by sequencing these 240 mini-bulk libraries with 1.2 billion reads ($\frac{1.2 \times 10^9}{240} = 5 \times 10^6$).
We further hoped that the majority of these reads would be exonic.

In fact, we obtained $1.362 \times 10^9$ reads, with approximately $77.29\%$ having a match^[Allowing up to 1 mismatch] to the 376 CEL-Seq2 well barcodes for a total of $1.053 \times 10^9$ usable reads.
A further $21.03\%$ of reads had no barcode match nor aligned to the reference genome^[This may appear higher than typical but it is because we did not use an Illumina index when sequencing in _S000448_ and so this includes what would normally be 'undetermined' reads.].

Further QC metrics are available in [`output/scPipe/RPI-43.scPipe_QC_report.nb.html`](../output/scPipe/RPI-43.scPipe_QC_report.nb.html)

## Analysis

```{r}
library(scPipe)
sce$nreads <- apply(QC_metrics(sce_deduped)[colnames(sce), ], 1, sum)
```

Figure \@ref(fig:nreads) - \@ref(fig:intronic) shows that we generated a median of `r number(median(sce$nreads[sce$sample_type != "empty"]) / 1e6, accuracy = 0.1)` million reads for each technical replicate with a median `r percent(median((sce$mapped_to_exon / sce$nreads)[sce$sample_type != "empty"]))` of these exonic and a median `r percent(median((sce$mapped_to_intron / sce$nreads)[sce$sample_type != "empty"]))` of these intronic.

::::: {.panelset}

::: {.panel}

### Number of reads

```{r}
#| nreads, 
#| fig.cap = "Number of reads generated per technical replicate. The black 
#|    dashed horizontal line denotes the median across all samples and the red 
#|    dashed horizontal lines denotes the maximum across all the 'empty' wells.",

plotColData(
  sce, 
  y = "nreads",
  x = "biological_replicate",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  colour_by = "cell_line",
  theme_size = 8) +
  scale_y_log10(limits = c(1, NA)) +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  geom_hline(
    yintercept = median(sce$nreads[sce$sample_type != "empty"]), 
    lty = 2) +
  geom_hline(
    yintercept = max(sce$nreads[sce$sample_type == "empty"]), 
    lty = 2,
    col = "red") +
  annotation_logticks(
    sides = "l",
    short = unit(0.03, "cm"),
    mid = unit(0.06, "cm"),
    long = unit(0.09, "cm")) +
  guides(colour = "none") +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)
```

:::

::: {.panel}

### Exonic %

```{r}
#| exonic, 
#| fig.cap = "Percentage of reads that are exonic per sample. The dashed 
#|    horizontal line denotes the median across all samples.",

plotColData(
  sce, 
  y = I(sce$mapped_to_exon / sce$nreads), 
  x = "biological_replicate",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  colour_by = "cell_line",
  theme_size = 8) +
  ylab("Percentage exonic") +
  geom_hline(
    yintercept = 
      median((sce$mapped_to_exon / sce$nreads)[sce$sample_type != "empty"]),
    lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  panel_border() +
  scale_y_continuous(labels = scales::percent, limits = c(0, 1)) +
  scale_colour_manual(values = cell_line_colours)
```

:::

::: {.panel}

### Intronic %

```{r}
#| intronic, 
#| fig.cap = "Percentage of reads that are intronic per sample. The dashed 
#|    horizontal line denotes the median across all samples.",

plotColData(
  sce, 
  y = I(sce$mapped_to_intron / sce$nreads), 
  x = "biological_replicate",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  colour_by = "cell_line",
  theme_size = 8) +
  ylab("Percentage intronic") +
  geom_hline(
    yintercept = 
      median((sce$mapped_to_intron / sce$nreads)[sce$sample_type != "empty"]),
    lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  panel_border() +
  scale_y_continuous(labels = scales::percent, limits = c(0, 1)) +
  scale_colour_manual(values = cell_line_colours)
```

:::

:::::

We observe that there are `r number(sum(sce$nreads[sce$sample_type != "empty"] < max(sce$nreads[sce$sample_type == "empty"])))` replicates, listed below, with fewer reads than the maximum number of reads from an 'empty' well (nreads = `r number(max(sce$nreads[sce$sample_type == "empty"]), big.mark = ",")`).
The majority of these are from `GID2KO`, particularly biological replicates `1` and `2`.

```{r}
colData(sce) |>
  as.data.frame() |>
  dplyr::filter(
    nreads < max(sce$nreads[sce$sample_type == "empty"]),
    sample_type != "empty") |>
  dplyr::select(
    sample, technical_replicate, well_position, nreads) |>
  dplyr::arrange(sample) |>
  knitr::kable(
    caption = "Metadata of samples with `nreads` less than the maximim number of of reads from an 'empty' well.",
    format.args = list(big.mark = ","),
    row.names = FALSE)
```

Figure \@ref(fig:plate-map) highlights on the 384-well plate layout which replicates have fewer reads than the maximum number of reads from an 'empty' well (nreads = `r number(max(sce$nreads[sce$sample_type == "empty"]), big.mark = ",")`), showing that the these cluster on the leftmost side of the plate (columns 1-2 in particular).

```{r}
#| plate-map,
#| fig.cap = "384-well plate layout highlighting wells with fewer reads than 
#|    the maximum number of reads from an 'empty' well.",
#| fig.asp = 1 / 2

plotPlatePosition(
  sce,
  as.character(sce$well_position),
  point_alpha = 1,
  point_size = 5,
  colour_by = I(sce$nreads <= max(sce$nreads[sce$sample_type == "empty"])),
  shape_by = "sample_type") +
  guides(
    colour = guide_legend(
      override.aes = list(size = 3, alpha = 1), 
      title = "nreads <= cutoff"),
    shape = guide_legend(
      override.aes = list(size = 3, alpha = 1),
      title = "sample_type")) +
  theme_cowplot(font_size = 8) +
  xlab("") +
  ylab("") +
  scale_colour_manual(values = c(`FALSE` = "#1b9e77", `TRUE` = "#d95f02"))
```

## Summary

We achieved our aim of roughly 5 million reads/replicate *pre-alignment* with `r number(median(sce$nreads[sce$sample_type != "empty"]) / 1e6, accuracy = 0.1)` reads/replicate *post-alignment*.
There is some notable variation in the number of reads generated, but `r percent(sum(sce$nreads[sce$sample_type != "empty"] > 1e6) / sum(sce$sample_type != "empty"))` replicates achieved at least 1 million reads/replicate.

**Henceforth, we only use the exonic reads.**
Although the intronic reads are potentially useful, to do so would require substantial changes to the data analysis workflow and additional analysis.

# Analysis of empty wells

## Background

As seen in Figure \@ref(fig:nreads), the 'empty' wells have reads with a median of `r number(median(sce$nreads[sce$sample_type == "empty"]), big.mark = ",")` reads, but as many as `r number(max(sce$nreads[sce$sample_type == "empty"]), big.mark = ",")` reads.
We'd obviously hope/expect that empty wells should not have any reads assigned to them, but this has been observed in previous CEL-Seq2 experiments.

Here, we explore the reads from these 'empty' wells to see what we can learn from them.

## Analysis

We estimate the ambient profile from the 'empty' wells and look at the most highly expressed genes in the profile.
Almost a third of the reads counts in the ambient profile come from *PF3D7_0726000*, an rRNA.

```{r}
reads_ap <- DropletUtils::ambientProfileEmpty(
  assay(sce, "read_counts"),
  known.empty = which(sce$sample_type == "empty"))
knitr::kable(
  data.frame(Contribution = percent(head(sort(reads_ap, decreasing = TRUE)))),
  caption = "Most highly expressed genes (using read counts) in the ambient profile and the corresponding contribution of counts from that gene to the profile.")
```

## Summary

We defer further investigation of the reads from the 'empty' wells and remove the 'empty' wells from the dataset.

```{r}
sce <- sce[, sce$sample_type != "empty"]
colData(sce) <- droplevels(colData(sce))
```

# Have we sequenced enough?

## Motivation

SCORE's mini-bulk protocol is still being finalised and some technical questions remain.
In particular, we want to know if we have sequenced enough to answer the biological questions of interest.

One way of estimating if we have sequenced enough uses a metric called 'sequencing saturation'.
10x Genomics have some useful information about sequencing saturation available [here](https://kb.10xgenomics.com/hc/en-us/articles/115005062366-What-is-sequencing-saturation-).
In particular,

>  Sequencing saturation is a measure of the fraction of library complexity that was sequenced in a given experiment. The inverse of the sequencing saturation can be interpreted as the number of additional reads it would take to detect a new transcript. ... Sequencing saturation is dependent on the library complexity and sequencing depth. Different cell types will have different amounts of RNA and thus will differ in the total number of different transcripts in the final library (also known as library complexity). ... As sequencing depth increases, more genes are detected, but this reaches saturation at different sequencing depths depending on cell type. ... Sequencing depth also affects sequencing saturation; generally, the more sequencing reads, the more additional unique transcripts you can detect. However, this is limited by the library complexity.

> This naturally leads to the question of ['how much sequencing saturation should I aim for?'](https://kb.10xgenomics.com/hc/en-us/articles/115002474263-How-much-sequencing-saturation-should-I-aim-for-), which very much depends on the goals of the experiment.

For this experiment, where we wish to assess differential expression between experimental groups, we will likely want quite high sequencing saturation.

## Analysis

To begin, we simply examine the number of reads sequenced/sample.

```{r}
reads_ls <- log10(colSums(assay(sce, "read_counts")))
```

Figure \@ref(fig:read-library-size) plots the distribution of the number of reads mapped to exons in each sample^[I.e. the 'library size' when using read counts].

```{r}
#| read-library-size, 
#| fig.cap = "Distribution of the number of reads mapped to exons in each 
#|    sample."

plot(
  density(reads_ls),
  xlab = expression(log[10](n[reads])),
  ylab = "density",
  xlim = range(reads_ls),
  main = "")
```

We estimate the sequencing saturation using [10x Genomics' formula](https://kb.10xgenomics.com/hc/en-us/articles/115003646912-How-is-sequencing-saturation-calculated-), 

$$
1 - (n_{deduped reads} / n_{reads})
$$
where:

- $n_{deduped reads}$ = Number of unique (valid cell-barcode, valid UMI, gene)-combinations among confidently mapped reads
- $n_{reads}$ = Total number of confidently mapped, valid cell-barcode, valid UMI reads

```{r}
saturation <- 1 - 
  (colSums(assay(sce, "UMI_counts")) / colSums(assay(sce, "read_counts")))
```

Figure \@ref(fig:saturation) shows that almost all samples are sequenced close to saturation, with a median of `r percent(mean(saturation), accuracy = 0.1)` saturation.

```{r}
#| saturation, 
#| fig.cap = "Distribution of the sequencing saturation."

par(mfrow = c(1, 1))
plot(
  density(
    saturation,
    from = 0,
    to = 1),
  xlab = "saturation",
  ylab = "density",
  xlim = c(0, 1),
  main = "Sequencing saturation")
```

## Summary

These results show that the libraries are sequenced to near-saturation.

One way to think of sequencing saturation is [provided by 10x Genomics](https://kb.10xgenomics.com/hc/en-us/articles/115002474263-How-much-sequencing-saturation-should-I-aim-for-):

> The inverse of the sequencing saturation can be interpreted as roughly the number of new transcripts you expect to find with one new read. If sequencing saturation is at 50%, it means that every 2 new reads will result in 1 new UMI count (unique transcript) detected. In contrast, 90% sequencing saturation means that 10 new reads are necessary to obtain one new UMI count. If the sequencing saturation is high, additional sequencing would not recover much new information for the library.

At this stage, it is not necessary to perform additional sequencing of the library.

# UMI counts vs. read counts

## Motivation

A unique feature of SCORE's 'mini-bulk' RNA-sequencing protocol is the incorporation of unique molecular identifiers (UMIs) into the library preparation; an ordinary bulk RNA-seq protocol does not incorporate UMIs.

UMIs are commonly used in single-cell RNA-sequencing protocols, such as the CEL-Seq2 protocol from which the mini-bulk protocol is adapted.
UMIs are molecular tags that are used to detect and quantify unique mRNA transcripts.
In this method, mRNA libraries are generated by fragmentation and reverse-transcribed to cDNA.
Oligo(dT) primers with specific sequencing linkers are added to the cDNA.
Another sequencing linker with a 6 bp random label and an index sequence is added to the 5' end of the template, which is amplified and sequenced.

<aside>
This explanation is adapted from [https://sapac.illumina.com/science/sequencing-method-explorer/kits-and-arrays/umi.html](https://sapac.illumina.com/science/sequencing-method-explorer/kits-and-arrays/umi.html).
</aside>

The UMI count is always less than or equal to the read count and a UMI count of zero also implies a read count of zero.

Pros of using UMIs:

- Can sequence unique mRNA transcripts
- Can detect transcripts occurring at low frequencies
- Transcripts can be quantified based on sequencing reads specific to each barcode

Cons of using UMIs:

- SCORE's mini-bulk protocol uses a $k=6$ bp UMI^[The choice of a 6 bp UMI in the mini-bulk protocol is because it is adapted from SCORE's CEL-Seq2 single-cell RNA-sequencing protocol. With scRNA-seq data it is very rare to observe more than $4^k = 4^6 = 4096$ unique molecules for any one gene.] and so (theoretically) the maximum UMI count for each gene is $4^6 = 4096$.
- There is therefore a risk that highly expressed genes may have their expression measurements artificially truncated, particularly if the sample is deeply sequenced.

To investigate whether expression measurements are being 'truncated' in this dataset, and decide whether to use the UMI counts or the read counts, we generated and now analyse two count matrices:

1. UMI counts (i.e. deduplicating UMI counts)
2. Read counts (i.e. not deduplicating UMI counts, equivalent to ignoring the UMIs)

## Analysis

```{r}
n <- apply(assay(sce, "read_counts"), 1, function(x) sum(x > 4 ^ 6))
g <- names(n[n > 0])
```

Figure \@ref(fig:read-distribution) plots the distribution of the logarithm of the read counts.
From this we see that the vast majority of read counts are small. 
In fact:

- `r percent(sum(as.vector(assay(sce, "read_counts")) == 0) / prod(dim(sce)), accuracy = 0.1)` of read counts are 0
- 95% of the read counts are no greater than `r number(quantile(as.vector(assay(sce, "read_counts")), 0.95), big.mark = ",")` 
- 99% of the read counts are no greater than `r number(quantile(as.vector(assay(sce, "read_counts")), 0.99), big.mark = ",")` 
- 99.9% of the read counts are no greater than `r number(quantile(as.vector(assay(sce, "read_counts")), 0.999), big.mark = ",")`

```{r}
#| read-distribution, 
#| fig.cap = "Distribution of the logarithm of the read counts as density plot 
#|    (left) and empirical cumulative distribution function (right). A count of 
#|    1 is added to each UMI count to avoid taking the logarithm of zero. The 
#|    orange vertical line denotes $4^6 = 4096$.", 
#| fig.asp = 1 / 2

x <- as.vector(assay(sce, "read_counts")) + 1L
par(mfrow = c(1, 2), cex = 0.5)
plot(
  density(log2(x), from = min(log2(x)), to = max(log2(x))),
  xlab = expression(log[2](reads + 1)),
  main = "",
  ylab = "density")
abline(v = log2(4 ^ 6), col = "orange")
plot(
  ecdf(log2(x)), 
  xlim = range(log2(x)),
  main = "",
  xlab = expression(log[2](reads + 1)),
  ylab = "cumulative density")
abline(v = log2(4 ^ 6), col = "orange")
```

Only `r percent(sum(as.vector(assay(sce, "read_counts")) > 4^6) / prod(dim(sce)), accuracy = 0.01)` of read counts exceed the $4^6 = 4096$ threshold.
However there are `r number(length(g), big.mark = ",")` genes for which at least one sample exceeds the $4^6=4096$ threshold; these genes are shown in the table below.
If we were to use the UMI counts, the genes in this list may have their expression measurements artificially truncated in those samples where the number of copies of the transcript exceed the $4^6=4096$ threshold.

This table shows that many of these genes are mitochondrial and ribosomal protein genes.

```{r}
read_e <- as.matrix(assay(sce, "read_counts")[g, ])
umi_e <- as.matrix(assay(sce, "UMI_counts")[g, ])
high_count_tbl <- tibble::tibble(
  gene = g,
  read_median_count = matrixStats::rowMedians(read_e),
  read_exceed_sum = matrixStats::rowSums2(read_e > 4 ^ 6),
  read_exceed_percent = read_exceed_sum / ncol(sce),
  umi_median_count = matrixStats::rowMedians(umi_e),
  umi_exceed_sum = matrixStats::rowSums2(umi_e > 4 ^ 6),
  umi_exceed_percent = umi_exceed_sum / ncol(sce)) %>%
  dplyr::arrange(desc(read_exceed_sum))
sketch <- htmltools::withTags(
  table(
    class = "display",
    thead(
      tr(
        th(rowspan = 2, "gene"),
        th(colspan = 3, "reads"),
        th(colspan = 3, "UMIs")
      ),
      tr(
        lapply(rep(c("median count", "N > 4096", "% > 4096"), 2), th)
      )
    )
  ))

DT::datatable(
  high_count_tbl, 
  caption = "Genes for which any sample has a read count exceeding the 4096 threshold and summaries of the corresponding read and UMI counts, namely: the median count ('median count'); the number of samples for which the counts exceed the threshold ('N > 4096'); and the percentage of samples for which the counts exceed the threshold ('% > 4096').",
  container = sketch,
  rownames = FALSE) %>%
  DT::formatPercentage(
    columns = c("read_exceed_percent", "umi_exceed_percent"),
    digits = 1) %>%
  DT::formatRound(
    columns = c("read_median_count", "umi_median_count"),
    digits = 0)
```

Figure \@ref(fig:scatterplot-and-ma-plot) plots the relationship between UMI counts and read counts for all genes and samples.
There are a few notable points about this figure:

1. The UMI counts and read counts are very strongly associated.
2. The log-fold change between the read counts and the UMI counts can be large, indicating the UMI counts are likely removing substantial PCR amplification noise.
3. The log-fold changes between the read counts and the UMI counts are larger on average for more highly expressed genes. The variation in the log-fold change is larger for the lowly expressed genes.

```{r}
#| scatterplot-and-ma-plot, 
#| fig.cap = "Scatterplot of the logarithm of the UMI and read counts (top)
#|    and logCPM of the UMI and read counts (bottom) for all genes and samples 
#|    (left) and mean-difference plot of the same data (right). The correlation
#|    in the scatterplot is reported below the x-axis label. Genes that are 
#|    ribosomal protein genes subunits are highlighted in orange and 
#|    mitochondrial genes in blue. The red line is a trend fitted to the
#|    mean-differences.", 
#| fig.asp = 1

x <- log2(as.vector(assay(sce, "UMI_counts")) + 1)
y <- log2(as.vector(assay(sce, "read_counts")) + 1)
m <- (x + y) / 2
d <- y - x
g <- rep(rownames(sce), ncol(sce))
# NOTE: Only showing unique points for plotting speed.
i <- !duplicated(paste0(x, ".", y))
X <- edgeR::cpm(assay(sce, "UMI_counts"), log = TRUE)
Y <- edgeR::cpm(assay(sce, "read_counts"), log = TRUE)
M <- (X + Y) / 2
D <- y - x
G <- g
# NOTE: Only showing unique points for plotting speed.
I <- !duplicated(paste0(x, ".", y))
par(mfrow = c(2, 2))
plotWithHighlights(
  x = x[i],
  y = y[i],
  status = ifelse(g[i] %in% ribo_set, 1, ifelse(g[i] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  sub = paste0("r = ", number(cor(x, y), accuracy = 0.001)),
  xlab = expression(log[2](UMIs + 1)),
  ylab = expression(log[2](reads + 1)))
abline(a = 0, b = 1, lty = 2, col = "grey")
plotWithHighlights(
  x = m[i] / 2,
  y = d[i],
  pch = ".",
  status = ifelse(g[i] %in% ribo_set, 1, ifelse(g[i] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  xlab = "Average log-(count+1)",
  ylab = "logFC (reads vs. UMIs)",
  ylim = c(-max(abs(c(d, D))), max(abs(c(d, D)))))
abline(h = 0, lty = 2, col = "grey")
l <- lowess(m, d, f = 0.3)
lines(l, col = "red", lwd = 2)
plotWithHighlights(
  x = X[I],
  y = Y[I],
  status = ifelse(G[I] %in% ribo_set, 1, ifelse(G[I] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  sub = paste0(
    "r = ", 
    number(cor(as.vector(X), as.vector(Y)), accuracy = 0.001)),
  xlab = expression(logCPM(UMIs)),
  ylab = expression(logCPM(reads)))
abline(a = 0, b = 1, lty = 2, col = "grey")
plotWithHighlights(
  x = M[I],
  y = D[i],
  status = ifelse(G[I] %in% ribo_set, 1, ifelse(G[I] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  xlab = "Average logCPM",
  ylab = "logFC (reads vs. UMIs)",
  ylim = c(-max(abs(c(d, D))), max(abs(c(d, D)))))
abline(h = 0, lty = 2, col = "grey")
l <- lowess(M, D, f = 0.3)
lines(l, col = "red", lwd = 2)
```

```{r}
X <- edgeR::cpm(assay(sce, "UMI_counts"), log = TRUE)
Y <- edgeR::cpm(assay(sce, "read_counts"), log = TRUE)
cor_j <- diag(cor(X, Y))
# NOTE: Splitting up the cor() computations is a hack to improve speed whilst 
#       keeping memory usage somewhat under control.
b <- 1000
s <- seq(1, by = b, to = nrow(sce))
e <- pmin(s + b - 1, nrow(sce))
cor_i <- unlist(
  Map(
    f = function(ss, ee ) diag(cor(t(X[ss:ee, ]), t(Y[ss:ee, ]))),
    ss = s,
    ee = e))
```

Rather than looking at all samples and all genes at once, we can also examine the relationship between UMI counts and read counts within a single sample across genes (Figure \@ref(fig:within-sample-cors)) and within a single gene across samples (Figure \@ref(fig:within-gene-cors)).
These figures show that the UMI counts and read counts are highly correlated across both samples (median = `r number(median(cor_j, na.rm = TRUE), accuracy = 0.001)`, median absolute deviation = `r number(mad(cor_j, na.rm = TRUE), accuracy = 0.001)`) and genes (median = `r number(median(cor_i, na.rm = TRUE), accuracy = 0.001)`, median absolute deviation = `r number(mad(cor_i, na.rm = TRUE), accuracy = 0.001)`).

::::: {.panelset}

::: {.panel}

### Within-sample

```{r}
#| within-sample-cors, 
#| fig.cap = "Association between UMI counts and read counts for each gene 
#|    within each sample. The first 8 panels are scatter plots of the UMI 
#|    counts and read counts for each gene for the samples with the 3 lowest
#|    correlations, 2 middlemost correlations, and 3 highest correlations. The
#|    correlation in the scatterplot is reported below each panel. Genes that 
#|    are ribosomal protein genes subunits are highlighted in orange and
#|    mitochondrial genes in blue. The final panel is the distribution of these
#|    correlations across all samples.",
#| fig.asp = 1

par(mfrow = c(3, 3), cex = 0.5)
jj <- names(sort(cor_j)[c(1:3, 119:120, 238:240)])
for (j in jj) {
  g <- rownames(sce)
  plot(
    x = X[, j],
    y = Y[, j],
    pch = ".",
    cex = ifelse(g %in% c(ribo_set, mito_set), 5, 1),
    col = ifelse(
      g %in% ribo_set, "orange",
      ifelse(g %in% mito_set, "dodgerBlue", "black")),
    sub = paste0("r = ", number(cor_j[j], accuracy = 0.001)),
    xlab = "logCPM(UMIs)",
    ylab = "logCPM(reads)",
    main = j,
    xlim = range(x),
    ylim = range(y))
  abline(a = 0, b = 1, col = "grey", lty = 2)
}
plot(
  density(cor_j, na.rm = TRUE, from = -1, to = 1),
  main = "All samples", 
  xlab = expression(r[p]))
```

:::

::: {.panel}

### Within-gene

```{r}
#| within-gene-cors, 
#| fig.cap = "Association between UMI counts and read counts for each sample 
#|    within each gene. The first 8 panels are scatter plots of the UMI counts
#|    and read counts for each sample for the genes with the 3 lowest 
#|    correlations, 2 middlemost correlations, and 3 highest correlations. The 
#|    correlation in the scatterplot is reported below each panel. Genes that 
#|    are ribosomal protein genes subunits are highlighted in orange and 
#|    mitochondrial genes in blue. The final panel is the distribution of 
#|    these correlations across all genes.",
#| fig.asp = 1

par(mfrow = c(3, 3), cex = 0.5)
ii <- names(sort(cor_i)[c(1:3, 2843:2844, 5685:5687)])
for (i in ii) {
  g <- i
  plot(
    x = X[i, ],
    y = Y[i, ],
    pch = 16,
    col = ifelse(
      g %in% ribo_set, "orange",
      ifelse(g %in% mito_set, "dodgerBlue", "black")),
    sub = paste0("r = ", number(cor_i[i], accuracy = 0.001)),
    xlab = "logCPM(UMIs)",
    ylab = "logCPM(reads)",
    main = i,
    xlim = range(X),
    ylim = range(Y))
  abline(a = 0, b = 1, col = "grey", lty = 2)
}
plot(
  density(cor_i, na.rm = TRUE, from = -1, to = 1),
  main = "All genes", 
  xlab = expression(r[p]))
```

:::

:::::

## Summary

The ultimate aim of this analysis is to perform a differential expression (DE) analysis. 
On the one hand, a DE analysis is more powerful when there are more counts available, which is where the read counts are favoured.
On the other hand, a DE analysis may be biased if these counts arise through PCR duplicates, which is where the deduplicated UMI counts are favoured.
The choice between using the read counts or the UMI counts in the DE analysis is therefore a trade-off between these two choices.

**For now, we defer our choice of read counts vs. UMI counts, but the remainder of this preprocessing report uses (exonic) read counts**.

# Quality control of cells

## Defining the quality control metrics

Low-quality cells need to be removed to ensure that technical effects do not distort downstream analysis results.
We use several quality control (QC) metrics to measure the quality of the cells:

- `sum`: This measures the library size of the samples, which is the total sum of counts across genes. We want samples to have high library sizes as this means more RNA has been successfully captured during library preparation. 
- `detected`: This is the number of expressed features^[The number of expressed genes refers to the number of genes which have non-zero counts (ie. they have been identified in the cell at least once)] in each cell. Cells with few expressed features are likely to be of poor quality, as the diverse transcript population has not been successful captured. 
- `altexps_ERCC_detected`: This measures the proportion of reads which are mapped to spike-in transcripts relative to the library size of each cell. High proportions are indicative of poor-quality cells, where endogenous RNA has been lost during processing (e.g., due to cell lysis or RNA degradation). 
The same amount of spike-in RNA to each cell, so an enrichment in spike-in counts is symptomatic of loss of endogenous RNA.
- `subsets_Mito_percent`: This measures the proportion of reads which are mapped to mitochondrial RNA. If there is a higher than expected proportion of mitochondrial RNA this is often symptomatic of a cell which is under stress and is therefore of low quality and will not be used for the analysis. 
- `subsets_Ribo_percent`: This measures the proportion of UMIs which are mapped to ribosomal protein genes. If there is a higher than expected proportion of ribosomal protein gene expression this is often symptomatic of a cell which is of compromised quality and we may want to exclude it from the analysis. 

```{r}
#| results = "hide"

is_mito <- rownames(sce) %in% mito_set
summary(is_mito)
is_ribo <- rownames(sce) %in% ribo_set
summary(is_ribo)
sce <- addPerCellQC(
  sce, 
  subsets = list(Mito = which(is_mito), Ribo = which(is_ribo)),
  assay.type = "read_counts")
```

## Visualizing the QC metrics

### Individual technical replicates

Figures \@ref(fig:qcplot-by-sample-gex-sum) - \@ref(fig:qcplot-by-sample-gex-ribo) compare the QC metrics of the mini-bulk samples.
These figures show that the vast majority of mini-bulk samples are good-quality with:

- The median library size is around `r number(median(sce$sum), accuracy = 1000, big.mark = ",")`.
- The median number of genes detected is around `r number(median(sce$detected), accuracy = 100, big.mark = ",")`.
- The median percentage of reads that are mapped to mitochondrial RNA is around  `r percent(median(sce$subsets_Mito_percent), scale = 1)`.

Samples with a low number of reads also have a low number of detected genes, which is to be expected.
All samples have a low percentage of mitochondrial RNA, but there are a few replicates that are outliers.

The median percentage of reads that are mapped to ribosomal protein genes is quite high, at around  `r percent(median(sce$subsets_Ribo_percent), scale = 1)`.
Such high percentages seems to be intrinsic to these samples.

::::: {.panelset}

::: {.panel}

#### Sum

```{r}
#| qcplot-by-sample-gex-sum,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    technical replicate in the dataset. Each point represents a technical 
#|    replicate and is coloured according to the legend."

p_sum <- plotColData(
  sce, 
  y = "sum",
  x = "biological_replicate",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  theme_size = 8) +
  geom_hline(yintercept = median(sce$sum), lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  scale_y_continuous(labels = comma) +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)

p_sum + ggtitle("GEX: Library size")
```

:::

::: {.panel}


#### Sum (log scale)

```{r}
#| qcplot-by-sample-gex-log-sum,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    technical replicate in the dataset. Each point represents a technical 
#|    replicate and is coloured according to the legend."

p_sum_log <- p_sum + 
  scale_y_log10(limits = c(1, NA), labels = comma) +
  annotation_logticks(
    sides = "l",
    short = unit(0.03, "cm"),
    mid = unit(0.06, "cm"),
    long = unit(0.09, "cm"))

p_sum_log + ggtitle("GEX: Library size (log scale)")
```

:::

::: {.panel}

#### Detected

```{r}
#| qcplot-by-sample-gex-detected,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    technical replicate in the dataset. Each point represents a technical 
#|    replicate and is coloured according to the legend."

p_detected <- plotColData(
  sce, 
  y = "detected",
  x = "biological_replicate",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  theme_size = 8) +
  geom_hline(yintercept = median(sce$detected), lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  scale_y_continuous(labels = comma) +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)

p_detected + ggtitle("GEX: Number of genes detected")
```

:::

::: {.panel}

#### Detected (log scale)

```{r}
#| qcplot-by-sample-gex-log-detected,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    technical replicate in the dataset. Each point represents a technical 
#|    replicate and is coloured according to the legend."

p_detected_log <- p_detected + 
  scale_y_log10(limits = c(1, NA), labels = comma) +
  annotation_logticks(
    sides = "l",
    short = unit(0.03, "cm"),
    mid = unit(0.06, "cm"),
    long = unit(0.09, "cm"))

p_detected_log + ggtitle("GEX: Number of genes detected (log scale)")
```

:::

::: {.panel}

#### Mitochondrial %

```{r}
#| qcplot-by-sample-gex-mito,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    technical replicate in the dataset. Each point represents a technical 
#|    replicate and is coloured according to the legend."

p_mito <- plotColData(
  sce, 
  y = "subsets_Mito_percent",
  x = "biological_replicate",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  theme_size = 8) +
  geom_hline(yintercept = median(sce$subsets_Mito_percent), lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  scale_y_continuous(
    labels = function(x) percent(x, scale = 1),
    limits = c(0, 100)) +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)

p_mito + ggtitle("GEX: Percentage mitochondrial expression")
```

:::

::: {.panel}

#### Ribosomal %

```{r}
#| qcplot-by-sample-gex-ribo,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    technical replicate in the dataset. Each point represents a technical 
#|    replicate and is coloured according to the legend."

p_ribo <- plotColData(
  sce, 
  y = "subsets_Ribo_percent",
  x = "biological_replicate",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields = c("cell_line", "timepoint"),
  theme_size = 8) +
  geom_hline(yintercept = median(sce$subsets_Ribo_percent), lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ cell_line, scales = "free_x") +
  scale_y_continuous(
    labels = function(x) percent(x, scale = 1), 
    limits = c(0, 100)) +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)

p_ribo + ggtitle("GEX: Percentage ribosomal expression")
```

:::

:::::

### Aggregated technical replicates

We will perform the differential expression analysis of the data by aggregating the technical duplicates by summing their counts.
Hence, we also look at at the QC metrics after this aggregation.

```{r}
#| results = "hide"

sce_aggregated <- aggregateAcrossCells(
  sce, 
  sce$sample, 
  use.assay.type = "read_counts")
sce_aggregated$sum <- 
  sce_aggregated$detected <- 
  sce_aggregated$subsets_Mito_percent <-
  sce_aggregated$subsets_Ribo_percent <- NULL

is_mito <- rownames(sce_aggregated) %in% mito_set
summary(is_mito)
is_ribo <- rownames(sce_aggregated) %in% ribo_set
summary(is_ribo)
sce_aggregated <- addPerCellQC(
  sce_aggregated, 
  subsets = list(Mito = which(is_mito), Ribo = which(is_ribo)),
  assay.type = "read_counts")
```

Figures \@ref(fig:qcplot-by-sample-gex-aggregated-sum) - \@ref(fig:qcplot-by-sample-gex-aggregated-ribo) compare the QC metrics of the mini-bulk samples.
These figures show that the vast majority of aggregatved mini-bulk samples are good-quality with:

- The median library size is around `r number(median(sce_aggregated$sum), accuracy = 1000, big.mark = ",")`.
- The median number of genes detected is around `r number(median(sce_aggregated$detected), accuracy = 100, big.mark = ",")`.
- The median percentage of reads that are mapped to mitochondrial RNA is around  `r percent(median(sce_aggregated$subsets_Mito_percent), scale = 1)`.

Samples with a low number of reads also have a low number of detected genes, which is to be expected.
All samples have a low percentage of mitochondrial RNA, but there are a few replicates that are outliers.

The median percentage of reads that are mapped to ribosomal protein genes is quite high, at around  `r percent(median(sce_aggregated$subsets_Ribo_percent), scale = 1)`.
Such high percentages seems to be intrinsic to these samples.

::::: {.panelset}

::: {.panel}

#### Sum

```{r}
#| qcplot-by-sample-gex-aggregated-sum,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    biological replicate in the dataset. Each point represents a biological 
#|    replicate and is coloured according to the legend."

p_sum <- plotColData(
  sce_aggregated, 
  y = "sum",
  x = "cell_line",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields =  "timepoint",
  theme_size = 8) +
  geom_hline(yintercept = median(sce$sum), lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ .) +
  scale_y_continuous(labels = comma) +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)

p_sum + ggtitle("GEX: Library size")
```

:::

::: {.panel}


#### Sum (log scale)

```{r}
#| qcplot-by-sample-gex-aggregated-log-sum,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    biological replicate in the dataset. Each point represents a biological 
#|    replicate and is coloured according to the legend."

p_sum_log <- p_sum + 
  scale_y_log10(limits = c(1, NA), labels = comma) +
  annotation_logticks(
    sides = "l",
    short = unit(0.03, "cm"),
    mid = unit(0.06, "cm"),
    long = unit(0.09, "cm"))

p_sum_log + ggtitle("GEX: Library size (log scale)")
```

:::

::: {.panel}

#### Detected

```{r}
#| qcplot-by-sample-gex-aggregated-detected,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    biological replicate in the dataset. Each point represents a biological 
#|    replicate and is coloured according to the legend."

p_detected <- plotColData(
  sce_aggregated, 
  y = "detected",
  x = "cell_line",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields =  "timepoint",
  theme_size = 8) +
  geom_hline(yintercept = median(sce$detected), lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ .) +
  scale_y_continuous(labels = comma) +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)

p_detected + ggtitle("GEX: Number of genes detected")
```

:::

::: {.panel}

#### Detected (log scale)

```{r}
#| qcplot-by-sample-gex-aggregated-log-detected,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    biological replicate in the dataset. Each point represents a biological 
#|    replicate and is coloured according to the legend."

p_detected_log <- p_detected + 
  scale_y_log10(limits = c(1, NA), labels = comma) +
  annotation_logticks(
    sides = "l",
    short = unit(0.03, "cm"),
    mid = unit(0.06, "cm"),
    long = unit(0.09, "cm"))

p_detected_log + ggtitle("GEX: Number of genes detected (log scale)")
```

:::

::: {.panel}

#### Mitochondrial %

```{r}
#| qcplot-by-sample-gex-aggregated-mito,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    biological replicate in the dataset. Each point represents a biological 
#|    replicate and is coloured according to the legend."

p_mito <- plotColData(
  sce_aggregated, 
  y = "subsets_Mito_percent",
  x = "cell_line",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields =  "timepoint",
  theme_size = 8) +
  geom_hline(yintercept = median(sce$subsets_Mito_percent), lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ .) +
  scale_y_continuous(
    labels = function(x) percent(x, scale = 1),
    limits = c(0, 100)) +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)

p_mito + ggtitle("GEX: Percentage mitochondrial expression")
```

:::

::: {.panel}

#### Ribosomal %

```{r}
#| qcplot-by-sample-gex-aggregated-ribo,
#| fig.cap = "Distribution of a QC metric (given in plot title) for each 
#|    biological replicate in the dataset. Each point represents a biological 
#|    replicate and is coloured according to the legend."

p_ribo <- plotColData(
  sce_aggregated, 
  y = "subsets_Ribo_percent",
  x = "cell_line",
  colour_by = "cell_line",
  point_alpha = 1,
  other_fields =  "timepoint",
  theme_size = 8) +
  geom_hline(yintercept = median(sce$subsets_Ribo_percent), lty = 2) +
  guides(colour = "none") +
  facet_grid(timepoint ~ .) +
  scale_y_continuous(
    labels = function(x) percent(x, scale = 1),
    limits = c(0, 100)) +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)

p_ribo + ggtitle("GEX: Percentage ribosomal expression")
```

:::

:::::

## Identifying outliers by each metric

Outliers are defined based on the median absolute deviation (MADs) from the median value of each metric across all cells.
We identify small outliers for the library size and the number of expressed features, and large outliers for the mitochondrial and ribosomal gene expression proportions.
Identification of low-quality cells is then performed by combining the filters for all of the metrics.

Note that we do this at the level of the unaggregated technical replicates.

```{r}
libsize_drop <- isOutlier(
  metric = sce$sum, 
  nmads = 3,
  type = "lower", 
  log = TRUE)
feature_drop <- isOutlier(
  metric = sce$detected,
  nmads = 3, 
  type = "lower", 
  log = TRUE)
mito_drop <- isOutlier(
  metric = sce$subsets_Mito_percent, 
  nmads = 3, 
  type = "higher")
ribo_drop <- isOutlier(
  metric = sce$subsets_Ribo_percent, 
  nmads = 3, 
  type = "higher")
```

The following table summarises the QC cutoffs:

```{r}
libsize_drop_df <- data.frame(
  cutoff = attributes(libsize_drop)$thresholds["lower"])
feature_drop_df <- data.frame(
  cutoff = attributes(feature_drop)$thresholds["lower"])
mito_drop_df <- data.frame(
  cutoff = attributes(mito_drop)$thresholds["higher"])
ribo_drop_df <- data.frame(
  cutoff = attributes(ribo_drop)$thresholds["higher"])
qc_cutoffs_df <- cbind(
    libsize_drop_df,
    feature_drop_df, 
    mito_drop_df, 
    ribo_drop_df)
colnames(qc_cutoffs_df) <- c(
  "total counts", "total features", "%mito", "%ribo")
knitr::kable(qc_cutoffs_df, caption = "QC cutoffs", digits = 1)
```

**We would typically remove outliers (e.g., small outliers for the library size and the number of expressed features, large outliers for mitochondrial or ribosomal gene expression percentage) at this stage.**
However, we opt to retain all replicates for the time being.
The following table highlights samples that would typically exclude as outliers by this criteria:

```{r}
keep <- !(libsize_drop | feature_drop | mito_drop | ribo_drop)
x <- cbind(
  data.frame(sample = colnames(sce), keep = keep),
  colData(sce)[
    ,
    c("sample", "sum", "detected", "subsets_Mito_percent", "subsets_Ribo_percent")])
row.names(x) <- NULL
DT::datatable(
  x[order(keep), ],
  caption = "Quality control metrics including library size (`sum`) and number of genes detected (`keep`) for each replicate. Each replicate is annotated by whether it would be kept or excluded by the typical quality control procedures (`keep`).",
  rownames = FALSE) |>
  DT::formatRound(c("subsets_Mito_percent", "subsets_Ribo_percent"))
```

## Summary

We have opted not to exclude any replicates at this stage.
However, we have identified some replicates with unusually small library sizes or number of genes detected or unusually high mitochondrial or mitochondrial gene expression percentage compared to the other samples.
We will keep an eye on these replicates and may later remove some of these in downstream analysis.

# Examining gene-level metrics

## Inspecting the most highly expressed genes

Figure \@ref(fig:topgenes) shows the most highly expressed genes across all samples.
The two most highly expressed genes, *PF3D7_0726000* and *PF3D7_0532000*, are rRNAs.
Figure \@ref(fig:topgenes-filtered) shows the most highly expressed endogenous genes after excluding the mitochondrial and ribosomal protein genes, where we observe genes that are more relevant to the cell types and biology we are trying to study.

::::: {.panelset}

::: {.panel}

### All genes

```{r}
#| topgenes, 
#| fig.asp = 1, 
#| fig.cap = "Percentage of total counts assigned to the top 50 most 
#|    highly-abundant features in the combined data set. For each feature, each 
#|    bar represents the percentage assigned to that feature for a single cell,
#|    while the circle represents the average across all cells."

plotHighestExprs(sce, n = 50, exprs_values = "read_counts")
```

:::

::: {.panel}

### Filtered genes

```{r}
#| topgenes-filtered, 
#| fig.asp = 1, 
#| fig.cap = "Percentage of total counts assigned to the top 50 most 
#|    highly-abundant features in the combined data set. For each feature, 
#|    each bar represents the percentage assigned to that feature for a single 
#|    cell, while the circle represents the average across all cells. Bars are
#|    coloured by the total number of expressed features in each cell, while 
#|    circles are coloured according to whether the feature is labelled as a 
#|    control feature."

plotHighestExprs(
  sce,
  drop_features = rownames(sce) %in% c(mito_set, ribo_set),
  n = 50,
  exprs_values = "read_counts")
```

:::

:::::

# MDS plot

We conclude with some MDS visualisations of the data.

## Invividual technical replicates

```{r}
assay(sce, "logCPM_reads") <- edgeR::cpm(assay(sce, "read_counts"), log = TRUE)
dec <- scran::modelGeneVar(sce, assay.type = "logCPM_reads")
hvg <- scran::getTopHVGs(dec, n = 1000)
sce <- runMDS(sce, subset_row = hvg, exprs_values = "logCPM_reads")
mds_df <- makePerCellDF(sce)
bg <- dplyr::select(
  mds_df, 
  -sample_type, -original_plate, -cell_line, -timepoint)
```

::::: {.panelset}

::: {.panel}

### Original plate

```{r}
#| mds-by-original-plate, 
#| fig.cap = "MDS plot of the dataset. Each point represents a sample and 
#|    is coloured by `original_plate` with each panel highlighting droplets 
#|    from a particular `original_plate`.",
#| fig.asp = 1 / 2

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 1) +
  geom_point(aes(colour = original_plate), alpha = 1, size = 2) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ original_plate, ncol = 2) +
  guides(colour = "none") +
  ggtitle("Faceted by sample_type") +
  panel_border()
```

:::

::: {.panel}

### Cell line

```{r}
#| mds-by-cell-line, 
#| fig.cap = "MDS plot of the dataset. Each point represents a sample and 
#|    is coloured by `cell_line` with each panel highlighting droplets from 
#|    a particular `cell_line`.",
#| fig.asp = 2 / 3

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 1) +
  geom_point(aes(colour = cell_line), alpha = 1, size = 2) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ cell_line, ncol = 3) +
  guides(colour = "none") +
  ggtitle("Faceted by cell_line") +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)
```

:::

::: {.panel}

### Timepoint

```{r}
#| mds-by-timepoint, 
#| fig.cap = "MDS plot of the dataset. Each point represents a sample and 
#|    is coloured by `timepoint` with each panel highlighting droplets from 
#|    a particular `timepoint`.",
#| fig.asp = 2 / 2

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 1) +
  geom_point(aes(colour = timepoint), alpha = 1, size = 2) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ timepoint, ncol = 2) +
  guides(colour = "none") +
  ggtitle("Faceted by timepoint") +
  panel_border() +
  scale_colour_manual(values = timepoint_colours)
```

:::

::: {.panel}

### Cell line + timepoint

```{r}
#| mds-by-cell-line-timepoint, 
#| fig.cap = "MDS plot of the dataset. Each point represents a sample and 
#|    is coloured by `cell_line` with each panel highlighting droplets from 
#|    a particular `cell_line`.",
#| fig.asp = 4 / 6

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.5) +
  geom_point(aes(colour = cell_line), alpha = 1, size = 1) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_grid(timepoint ~ cell_line) +
  guides(colour = "none") +
  ggtitle("Faceted by cell_line + timepoint") +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)
```

:::

::: {.panel}

### Library size

```{r}
#| mds-by-library-size, 
#| fig.cap = "MDS plot of the dataset. Each point represents a sample and 
#|    is coloured by library size (log10(`sum`)).",
#| fig.asp = 4 / 5

scater::plotMDS(
  sce,
  colour_by = data.frame(`log10(sum)` = log10(sce$sum), check.names = FALSE), 
  point_alpha = 1,
  point_size = 2)
```

:::

:::::

## Aggregated technical replicates

```{r}
assay(sce_aggregated, "logCPM_reads") <- edgeR::cpm(
  assay(sce_aggregated, "read_counts"), 
  log = TRUE)
dec <- scran::modelGeneVar(sce_aggregated, assay.type = "logCPM_reads")
hvg <- scran::getTopHVGs(dec, n = 1000)
sce_aggregated <- runMDS(
  sce_aggregated, 
  subset_row = hvg, 
  exprs_values = "logCPM_reads")
mds_df <- makePerCellDF(sce_aggregated)
bg <- dplyr::select(
  mds_df, 
  -sample_type, -original_plate, -cell_line, -timepoint)
```

::::: {.panelset}

::: {.panel}

### Original plate

```{r}
#| aggregated-mds-by-original-plate, 
#| fig.cap = "MDS plot of the aggregated dataset. Each point represents a 
#|    sample and is coloured by `original_plate` with each panel highlighting 
#|    droplets from a particular `original_plate`.",
#| fig.asp = 1 / 2

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 1) +
  geom_point(aes(colour = original_plate), alpha = 1, size = 2) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ original_plate, ncol = 2) +
  guides(colour = "none") +
  ggtitle("Faceted by sample_type") +
  panel_border()
```

:::

::: {.panel}

### Cell line

```{r}
#| aggregated-mds-by-cell-line, 
#| fig.cap = "MDS plot of the aggregated dataset. Each point represents a 
#|    sample and is coloured by `cell_line` with each panel highlighting 
#|    droplets from a particular `cell_line`.",
#| fig.asp = 2 / 3

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 1) +
  geom_point(aes(colour = cell_line), alpha = 1, size = 2) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ cell_line, ncol = 3) +
  guides(colour = "none") +
  ggtitle("Faceted by cell_line") +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)
```

:::

::: {.panel}

### Timepoint

```{r}
#| aggregated-mds-by-timepoint, 
#| fig.cap = "MDS plot of the aggregated dataset. Each point represents a 
#|    sample and is coloured by `timepoint` with each panel highlighting 
#|    droplets from a particular `timepoint`.",
#| fig.asp = 2 / 2

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 1) +
  geom_point(aes(colour = timepoint), alpha = 1, size = 2) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ timepoint, ncol = 2) +
  guides(colour = "none") +
  ggtitle("Faceted by timepoint") +
  panel_border() +
  scale_colour_manual(values = timepoint_colours)
```

:::

::: {.panel}

### Cell line + timepoint

```{r}
#| aggregated-mds-by-cell-line-timepoint, 
#| fig.cap = "MDS plot of the aggregated dataset. Each point represents a 
#|    sample and is coloured by `cell_line` with each panel highlighting 
#|    droplets from a particular `cell_line`.",
#| fig.asp = 2 / 3

ggplot(aes(x = MDS.1, y = MDS.2), data = mds_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.5) +
  geom_point(aes(colour = cell_line), alpha = 1, size = 1) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_grid(timepoint ~ cell_line) +
  guides(colour = "none") +
  ggtitle("Faceted by cell_line + timepoint") +
  panel_border() +
  scale_colour_manual(values = cell_line_colours)
```

:::

::: {.panel}

### Library size

```{r}
#| aggregated-mds-by-library-size, 
#| fig.cap = "MDS plot of the aggregated dataset. Each point represents a 
#|    sample and is coloured by library size (log10(`sum`)).",
#| fig.asp = 4 / 5

scater::plotMDS(
  sce_aggregated,
  colour_by = data.frame(
    `log10(sum)` = log10(sce_aggregated$sum),
    check.names = FALSE), 
  point_alpha = 1,
  point_size = 2)
```

:::

:::::

## Summary

Although Figures \@ref(fig:mds-by-original-plate) - \@ref(fig:aggregated-mds-by-library-size) are only a preliminary summary of the data, there are few patterns worth highlighting:

- Strong association of MDS co-ordinates and `timepoint`
- No strong association of MDS co-ordinates and `cell_line`, but this may become more apparent after accounting for `timepoint`.
- Replicates with small library sizes (i.e. low-quality replicates) cluster separately from the others and may need to be removed or downweighted in downstream analyses.

# Concluding remarks

```{r}
# Remove some unneeded assays and reducedDims.
assay(sce, "logCPM_reads") <- NULL
reducedDims(sce) <- NULL

# Save
saveRDS(
  sce,
  here("data", "SCEs", "G000396_Danu.preprocessed.SCE.rds"),
  compress = "xz")
```

The processed *SingleCellExperiment* object is available (see [`data/SCEs/G000396_Danu.preprocessed.SCE.rds`](../data/SCEs/G000396_Danu.preprocessed.SCE.rds)).
This will be used in downstream analyses, i.e. differential expression analysis.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

</details>
